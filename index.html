<!DOCTYPE html>
<!-- saved from url=(0022)http://localhost:8000/ -->
<html lang="en" style="--rocket-counter-font-size: 14px; --rocket-counter-padding: 1px 4px; --rocket-counter-radius: 8px; --rocket-counter-scale: 0.9; --rocket-counter-offset-x: 33px; --rocket-counter-offset-y: 13px; --rocket-counter-bg: rgba(0, 0, 0, 0.7); --rocket-counter-border: 1px solid rgb(107, 73, 73); --water-effect-color: rgba(0, 255, 255, 0.6); --water-effect-transition: 0.5s ease-out; --rocket-water-level-1: 33%; --rocket-water-level-2: 66%; --rocket-water-level-3: 100%; --dialog-width: 380px; --dialog-top-offset: 100px; --dialog-padding: 20px; --dialog-padding-bottom: 60px; --button-horizontal-offset: 90px; --button-bottom-offset: 30px; --health-bar-top: 1000px; --health-text-top: 970px; --close-button-width: 90px; --close-button-height: 30px; --scale: 1;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>骰子冒险 Demo</title>
  <style>
    :root {
      --game-width: 720px;
      --game-height: 1280px;
      --scale: 1;
      --dialog-width: 380px;
      --dialog-top-offset: 100px;
      --dialog-padding: 20px;
      --dialog-padding-bottom: 60px;
      --button-horizontal-offset: 90px;
      --button-bottom-offset: 30px;
      --health-bar-top: 1000px;
      --health-text-top: 970px;
      --shield-width: 4px;
      --shield-height: 54px;
      --shield-color: #000000;
      --rocket-counter-font-size: 12px;
      --rocket-counter-padding: 2px 4px;
      --rocket-counter-radius: 10px;
      --rocket-counter-scale: 0.9;
      --rocket-counter-offset-x: 0px;
      --rocket-counter-offset-y: 0px;
      --rocket-counter-bg: #ff6b6b;
      --rocket-counter-border: 2px solid #ff8e53;
      --water-effect-color: rgba(0, 174, 255, 0.7);  /* 默认水位效果颜色 */
      --water-effect-transition: 0.5s ease-out;  /* 默认过渡效果 */
      --rocket-water-level-1: 33%;
      --rocket-water-level-2: 66%;
      --rocket-water-level-3: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #1a1a1a;
    }

    #game-container {
      width: var(--game-width);
      height: var(--game-height);
      transform: scale(var(--scale));
      transform-origin: top center;
      background-image: url('bg.jpg');
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    #start-screen,
    #battle-screen {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    #start-screen {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-image: url('bg.jpg');
      background-size: cover;
      background-position: center;
    }

    #start-screen h1 {
      color: #ffffff;
      font-size: 48px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 40px;
    }

    #start-btn {
      padding: 15px 40px;
      font-size: 30px;
      color: #ffffff;
      background: linear-gradient(45deg, #ff6b6b, #ff8e53);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    #start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #ff8e53, #ff6b6b);
    }

    #start-btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    #talent-btn {
      padding: 12px 30px;
      font-size: 20px;
      color: #ffffff;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin-top: 20px;
    }

    #talent-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
      background: linear-gradient(45deg, #764ba2, #667eea);
    }

    #talent-btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .ripple {
      position: absolute;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      transform: scale(0);
      animation: ripple-effect 0.6s linear;
      pointer-events: none;
    }

    @keyframes ripple-effect {
      to {
        transform: scale(2);
        opacity: 0;
      }
    }

    /* 战斗界面样式 */
    #battle-screen {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      display: none;
      overflow: visible; /* 允许怪物在screen外显示 */
    }

    #enemy-panel {
      height: 30%;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    #dice-panel {
      height: 40%;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    #energy-bar {
      height: 30px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      margin-bottom: 20px;
    }

    #card-hand {
      height: 20%;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      position: relative;
    }

    #grid {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-60%, -50%);
      margin-top: -50px;
      margin-left: 10px;
      width: 166px;
      height: 166px;
      border: 2px solid rgba(151, 53, 53, 0.5);  /* 改为红色半透明边框 */
      background: none;
      padding: 2px;
      border-radius: 2px;
      transition: border-color 0.3s ease;
      display: grid;
      grid-template-areas: 
        "cell1 cell2 cell3"
        "cell4 empty cell6"
        "cell7 cell8 cell9";
      grid-template-columns: repeat(3, 54px);
      grid-template-rows: repeat(3, 54px);
      grid-gap: 2px;
      justify-content: center;
      align-content: center;
    }

    .cell {
      width: 54px;
      height: 54px;
      background-image: url('player.png');
      background-size: cover;
      background-position: center;
      border-radius: 2px;
      cursor: pointer;
      transition: transform 0.2s ease;
      z-index: 1;
      position: relative;
    }

    .wave-count {
      position: absolute;
      top: -10px;
      right: -10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: bold;
      border: 1px solid rgb(107, 73, 73);
      z-index: 1000;
    }

    /* 特别为gem2的数字显示设置样式 */
    .cell.gem2 .wave-count {
      right: auto;  /* 移除右对齐 */
      left: -10px;  /* 设置左对齐 */
      z-index: 2000;  /* 确保在最上层 */
    }

    .cell.hidden {
      visibility: hidden;
    }

    .cell.gem1 {
      background-image: url('gem1.png');
      position: relative;
    }

    .cell.gem1 .wave-count {
      display: block;  /* 确保gem1的波数显示 */
    }

    .cell.gem1::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--water-effect-color);  /* 使用统一的水位效果颜色变量 */
      transition: var(--water-effect-transition);  /* 使用配置的过渡效果 */
      pointer-events: none;
      z-index: 2;
    }

    .cell.gem1.wave-1::after { height: 20%; }
    .cell.gem1.wave-2::after { height: 40%; }
    .cell.gem1.wave-3::after { height: 60%; }

    .cell.gold-cell {
      background-size: contain !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      position: relative;
      animation: goldGlow 2s ease-in-out infinite alternate;
    }

    @keyframes goldGlow {
      0% {
        box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        transform: scale(1);
      }
      100% {
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        transform: scale(1.05);
      }
    }
    
    /* 边界红色呼吸动画 */
    .grid-boundary-alert {
      animation: boundaryBreathing 1s ease-in-out infinite alternate;
    }

    @keyframes boundaryBreathing {
      0% {
        border-color: rgba(255, 0, 0, 0.5);
        box-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
      }
      100% {
        border-color: rgba(255, 0, 0, 1);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
      }
    }

    @keyframes goldGainFloat {
      0% {
        opacity: 1;
        transform: translateY(0) translateX(-50%);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px) translateX(-50%);
      }
    }
    
    @keyframes upgradeFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      50% {
        transform: translateY(-20px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateY(-40px) scale(0.8);
      }
    }
    .cell.gem1.wave-4::after { height: 80%; }
    .cell.gem1.wave-5::after { height: 100%; }

    @keyframes waterRipple {
      0% { transform: scale(1); opacity: 0.7; }
      100% { transform: scale(1.2); opacity: 0; }
    }

    .cell.gem1::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 255, 255, 0.3) 0%, transparent 70%);
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }

    .cell.gem1.ripple::before {
      animation: waterRipple 0.5s ease-out;
    }

    .cell.gem2 {
      background-image: url('gem2.png');
      position: relative;
    }

    /* 将overflow: hidden移到水位效果的容器上 */
    .cell.gem2 .water-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .cell.gem2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--water-effect-color);  /* 使用统一的水位效果颜色变量 */
      transition: var(--water-effect-transition);  /* 使用配置的过渡效果 */
      pointer-events: none;
      z-index: 2;
    }

    .cell.gem2.wave-1::after { height: 50%; }
    .cell.gem2.wave-2::after { height: 100%; }

    .cell.gem2::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 255, 255, 0.3) 0%, transparent 70%);
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }

    .cell.gem2.ripple::before {
      animation: waterRipple 0.5s ease-out;
    }

    /* 英雄等级显示 */
    .gem2-level {
      position: absolute;
      top: 5px;
      left: 5px;
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: bold;
      z-index: 3;
      border: 1px solid #2e7d32;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* 不同等级的英雄格子样式 */
    .cell.gem2-level-1 {
      filter: brightness(1);
    }
    
    .cell.gem2-level-2 {
      filter: brightness(1.1) hue-rotate(30deg);
    }
    
    .cell.gem2-level-2 .gem2-level {
      background: linear-gradient(45deg, #FF9800, #F57C00);
      border-color: #E65100;
    }
    
    .cell.gem2-level-3 {
      filter: brightness(1.2) hue-rotate(60deg);
    }
    
    .cell.gem2-level-3 .gem2-level {
      background: linear-gradient(45deg, #9C27B0, #7B1FA2);
      border-color: #4A148C;
    }
    
    .cell.gem2-level-4 {
      filter: brightness(1.3) hue-rotate(90deg);
    }
    
    .cell.gem2-level-4 .gem2-level {
      background: linear-gradient(45deg, #F44336, #D32F2F);
      border-color: #B71C1C;
    }
    
    .cell.gem2-level-5 {
      filter: brightness(1.4) hue-rotate(120deg);
      animation: gem2-max-level 2s ease-in-out infinite;
    }
    
    .cell.gem2-level-5 .gem2-level {
      background: linear-gradient(45deg, #FFD700, #FFA000);
      border-color: #FF6F00;
      animation: gem2-level-glow 1.5s ease-in-out infinite;
    }

    /* 升级特效 */
    .upgrade-effect {
      animation: upgrade-pulse 0.5s ease-out;
    }

    @keyframes upgrade-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); box-shadow: 0 0 20px #4CAF50; }
      100% { transform: scale(1); }
    }

    @keyframes gem2-max-level {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes gem2-level-glow {
      0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
    }

    .cell.active {
      transform: scale(1.1);
      z-index: 2;  /* 激活时提升层级，但仍在角色下面 */
    }

    .player {
      width: 60px; /* 调整为格子大小 */
      height: 60px; /* 调整为格子大小 */
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      position: absolute;
      border-radius: 4px;
      z-index: 50;
      transform-origin: center;
      transform: translate(-60%, -60%); /* 居中对齐 */
    }

    /* 分离位置过渡和翻转效果 */
    .player-movement {
      transition: left 0.5s ease, top 0.5s ease;
    }

    .player.flip {
      transform: translate(-60%, -60%) scaleX(-1); /* 合并居中和翻转效果 */
    }

    @keyframes playerAnimation {
      0% { 
        background-image: url('player1.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      33.33% { 
        background-image: url('player2.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      66.66% { 
        background-image: url('player3.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      100% { 
        background-image: url('player1.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
    }

    /* 移除之前的定位样式 */
    .cell:nth-child(1), .cell:nth-child(2), .cell:nth-child(3),
    .cell:nth-child(4), .cell:nth-child(5), .cell:nth-child(6),
    .cell:nth-child(7), .cell:nth-child(8), .cell:nth-child(9) {
      left: auto;
      top: auto;
    }

    .upgrade-dialog {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: calc(50% + var(--dialog-top-offset));
      width: var(--dialog-width);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgb(107, 73, 73);
      border-radius: 4px;
      padding: var(--dialog-padding);
      padding-bottom: var(--dialog-padding-bottom);
      text-align: center;
      display: none;
      z-index: 9999;  /* 设置最高层级 */
    }

    /* 确保对话框内的所有元素也在最上层 */
    .upgrade-dialog * {
      z-index: 10000;
    }

    .upgrade-dialog h2 {
      color: white;
      margin-bottom: 10px;
      font-size: 24px;
      margin-top: -20px;
    }

    .dialog-button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 5px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    /* 游戏失败对话框样式 */
    .game-over-dialog {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #ff6b6b;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      display: none;
      z-index: 10000;
      box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
    }

    .game-over-dialog h2 {
      color: #ff6b6b;
      margin-bottom: 15px;
      font-size: 28px;
      margin-top: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .game-over-dialog p {
      color: white;
      margin-bottom: 25px;
      font-size: 16px;
      opacity: 0.9;
    }

    .game-over-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .restart-button, .quit-button {
      padding: 12px 25px;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .restart-button {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    .restart-button:hover {
      background: linear-gradient(45deg, #45a049, #4CAF50);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }

    .quit-button {
      background: linear-gradient(45deg, #f44336, #d32f2f);
      color: white;
    }

    .quit-button:hover {
      background: linear-gradient(45deg, #d32f2f, #f44336);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
    }

    .refresh-button {
      position: absolute;
      left: var(--button-horizontal-offset);
      bottom: var(--button-bottom-offset);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .close-button {
      position: absolute;
      right: var(--button-horizontal-offset);
      bottom: var(--button-bottom-offset);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 60px;   /* 修改为60像素 */
      height: 54px; /* 修改为60像素 */
      padding: 0;
      display: flex;
      justify-content: center;
      font-size: 20px; /* 添加字号20像素 */
      transition: transform 0.1s ease;
    }

    .close-button:active {
      transform: translateY(3px);
    }

    .button-text {
      color: white;
      margin-bottom: 2px;
    }

    .refresh-cost-container {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .upgrade-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      position: relative;
      padding-bottom: 70px;  /* 从50px增加到70px，为按钮留出更多空间 */
    }

    .upgrade-button {
      width: 110px;  /* 新的宽度 */
      height: 60px;   /* 新的高度 */
      border: none;
      border-radius: 2px;
      color: white;
      font-size: 22px;  /* 调整文字大小 */
      cursor: pointer;
      background-size: cover;
      background-position: center;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);  /* 添加文字阴影 */
    }

    .upgrade-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .upgrade-button:active {
      transform: translateY(3px);
      transition: transform 0.1s ease;
    }

    .upgrade-button-text {
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      font-size: 24px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      pointer-events: none;  /* 防止文字影响按钮点击 */
    }

    .coin-button {
      background-image: url('pt-button.png');
    }

    .health-button {
      background-image: url('wn-button.png');
    }

    .hero-button {
      background-image: url('jy-button.png');
    }

    .rocket-button {
      background-image: url('rocket-button.png');
    }

    .shield-button {
      background-image: url('shield-button.png');
    }

    .speed-button {
      background-image: url('speed-button.png');
    }

    .cost-indicator {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 8px;
      border-radius: 10px;
      white-space: nowrap;  /* 防止文字换行 */
      z-index: 1;  /* 确保显示在最上层 */
    }

    .coin-icon {
      width: 20px;
      height: 20px;
      background-image: url('gold.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      display: inline-block;
    }

    .cost-amount {
      color: #FFD700;
      font-size: 18px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .gold-display {
      position: fixed;  /* 改为fixed定位 */
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 15px;
      border: 1px solid rgb(107, 73, 73);
      z-index: 1000;  /* 确保显示在最上层 */
    }

    .gold-icon {
      width: 24px;
      height: 24px;
      background-image: url('gold.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      margin-right: 5px;
      display: inline-block;  /* 确保图标正确显示 */
    }

    .gold-amount {
      color: white;
      font-size: 20px;
      font-weight: bold;
      line-height: 24px;  /* 与图标高度对齐 */
      display: inline-block;  /* 确保文字正确显示 */
    }

    /* 怪物样式 */
    .monster {
      position: fixed;
      width: 60px;
      height: 60px;
      background-image: url('xiao_lv.png');
      background-size: cover;
      background-position: center;
      transform: translate(0, 0);
      transition: all 0.1s linear;
      z-index: 10;
      pointer-events: none;
    }

    /* BOSS样式 */
    .monster.boss {
      width: 80px;
      height: 80px;
      z-index: 11;
    }

    @keyframes bossAnimation {
      0% { background-image: url('BOSS.png'); }
      33.33% { background-image: url('BOSS1.png'); }
      66.66% { background-image: url('BOSS2.png'); }
      100% { background-image: url('BOSS.png'); }
    }

    /* 血条样式 */
    .health-bar {
      position: absolute;
      top: var(--health-bar-top);
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 25px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgb(107, 73, 73);
      border-radius: 10px;
      overflow: hidden;
    }

    .health-fill {
      width: 100%;
      height: 100%;
      background: #33bb33;
      transition: width 0.3s ease;
    }

    .health-text {
      position: absolute;
      top: var(--health-text-top);
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 20px;
      font-weight: bold;
      text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
    }

    /* 飘血动画 */
    @keyframes floatDamage {
      0% { transform: translate(-50%, 0); opacity: 1; }
      100% { transform: translate(-50%, -50px); opacity: 0; }
    }

    .damage-text {
      position: absolute;
      color: red;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      animation: floatDamage 1s ease-out forwards;
      z-index: 1001;
    }

    /* 技能效果 */
    .skill {
      position: fixed;
      width: 20px;
      height: 20px;
      background: cyan;
      border-radius: 50%;
      pointer-events: none;
      z-index: 1002;
    }

    /* 怪物血条 */
    .monster-health {
      position: absolute;
      top: -10px;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 2px;
      overflow: hidden;
    }

    .monster-health-fill {
      width: 100%;
      height: 100%;
      background: #33bb33;
      transition: width 0.2s ease;
    }

    /* 波数显示样式 */
    .wave-indicator {
      position: absolute;
      top: 100px;
      left: 250px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 15px;
      border-radius: 15px;
      border: 2px solid rgb(107, 73, 73);
      font-size: 18px;
      font-weight: bold;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .level-name-text {
      font-size: 14px;
      color: #ffd700;
      text-align: center;
      margin-bottom: 3px;
    }
    
    .wave-indicator > span {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .wave-progress {
      width: 100px;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-left: 10px;
    }

    .wave-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      width: 0%;
      transition: width 0.3s ease;
    }

    /* 金币动画 */
    .coin {
      position: fixed;
      width: 24px;
      height: 24px;
      background-image: url('gold.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      pointer-events: none;
      z-index: 1004;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes coinFloat {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      50% {
        transform: translateY(-20px) scale(1.2);
      }
      100% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    .refresh-cost {
      color: #FFD700;
      font-size: 14px;
      transition: color 0.3s;
    }

    .refresh-cost.insufficient {
      color: #ff4444;
    }

    .cost-amount.insufficient {
      color: #ff4444;
    }

    /* 添加新的样式 */
    .shield-effect {
      position: absolute;
      width: var(--shield-width);
      height: var(--shield-height);
      background-image: url('shield.png');
      background-size: cover;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3;
    }

    .shield-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 2px solid #00ffff;
      box-shadow: 0 0 10px #00ffff, inset 0 0 10px #00ffff;
      animation: shieldPulse 2s infinite;
      pointer-events: none;
      z-index: 2;
    }

    @keyframes shieldPulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }

    .cell.has-shield {
      position: relative;
    }

    .shield-health {
      position: absolute;
      top: 0px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 255, 0.3);
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 12px;
      z-index: 11;
    }

    .rocket {
      position: absolute;
      width: 30px;
      height: 30px;
      background-image: url('rocket1.png');
      background-size: contain;
      background-repeat: no-repeat;
      z-index: 1003;
      pointer-events: none;
    }

    /* 添加speed格子的样式 */
    .cell.speed {
      background-image: url('speed.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: relative;
    }



    .speed-level {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 0, 0.8);
      color: black;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: bold;
      z-index: 1000;
    }

    .upgrade-button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* 修改盾牌光效的CSS样式 */
    @keyframes shieldPulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }

    .shield-border {
      transition: all 0.3s ease;
    }

    /* 不同等级的盾牌光效 */
    .shield-border.level-1 {
      border: 4px solid rgba(0, 255, 255, 0.5);
      box-shadow: 0 0 10px #00ffff, inset 0 0 10px #00ffff;
    }

    .shield-border.level-2 {
      border: 5px solid rgba(0, 255, 255, 0.6);
      box-shadow: 0 0 15px #00ffff, inset 0 0 15px #00ffff;
    }

    .shield-border.level-3 {
      border: 6px solid rgba(0, 255, 255, 0.7);
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
    }

    .shield-border.level-4 {
      border: 7px solid rgba(0, 255, 255, 0.8);
      box-shadow: 0 0 25px #00ffff, inset 0 0 25px #00ffff;
    }

    .shield-border.level-5 {
      border: 8px solid rgba(0, 255, 255, 0.9);
      box-shadow: 0 0 30px #00ffff, inset 0 0 30px #00ffff;
    }

    /* 火箭格子样式 */
    .cell[data-has-rocket="true"] {
      position: relative;
      overflow: hidden;
      background: none !important;  /* 移除背景图片 */
    }

    /* 火箭图片样式 */
    .cell[data-has-rocket="true"] .cell-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: all 0.3s ease;
      z-index: 1;
    }

    /* 水位效果容器 */
    .cell[data-has-rocket="true"] .water-effect {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--water-effect-color);  /* 使用统一的水位效果颜色变量 */
      transition: var(--water-effect-transition);  /* 使用配置的过渡效果 */
      pointer-events: none;
      z-index: 2;  /* 水位效果在火箭图片之上 */
    }

    /* 水位等级 */
    .cell[data-has-rocket="true"][data-pass-count="1"] .water-effect { 
      height: var(--rocket-water-level-1); 
    }
    .cell[data-has-rocket="true"][data-pass-count="2"] .water-effect { 
      height: var(--rocket-water-level-2); 
    }
    .cell[data-has-rocket="true"][data-pass-count="3"] .water-effect { 
      height: var(--rocket-water-level-3); 
    }

    /* 计数器样式 */
    .cell[data-has-rocket="true"] .wave-count {
      position: absolute;
      z-index: 3;  /* 计数器在最上层 */
    }

    .cell[data-has-rocket="true"] .wave-count:first-of-type {
      left: calc(-1 * var(--rocket-counter-offset-x));
      top: calc(-1 * var(--rocket-counter-offset-y));
    }

    .cell[data-has-rocket="true"] .wave-count:last-child {
      right: calc(-1 * var(--rocket-counter-offset-x));
      top: calc(-1 * var(--rocket-counter-offset-y));
    }

    /* gem1的水位效果 */
    .cell.gem1::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--water-effect-color);  /* 使用统一的水位效果颜色变量 */
      transition: var(--water-effect-transition);  /* 使用配置的过渡效果 */
      pointer-events: none;
      z-index: 2;
    }

    /* gem2的水位效果 */
    .cell.gem2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--water-effect-color);  /* 使用统一的水位效果颜色变量 */
      transition: var(--water-effect-transition);  /* 使用配置的过渡效果 */
      pointer-events: none;
      z-index: 2;
    }

    /* 火箭等级效果 */
    .cell[data-rocket-level="1"] .cell-image {
      filter: brightness(1);
    }

    .cell[data-rocket-level="2"] .cell-image {
      filter: brightness(1.2);
    }

    .cell[data-rocket-level="3"] .cell-image {
      filter: brightness(1.4);
    }

    .cell[data-rocket-level="4"] .cell-image {
      filter: brightness(1.6);
    }

    .cell[data-rocket-level="5"] .cell-image {
      filter: brightness(1.8);
    }

    /* 火箭发射动画 */
    @keyframes rocketLaunch {
      0% { 
        transform: scale(1); 
        opacity: 1;
        background-image: url('rocket.png');
      }
      50% { 
        transform: scale(1.2); 
        opacity: 1;
        background-image: url('rocket1.png');
      }
      100% { 
        transform: scale(1); 
        opacity: 1;
        background-image: url('rocket.png');
      }
    }

    .cell.launching .cell-image {
      animation: rocketLaunch 0.3s ease;
    }

    /* 火箭格子数字显示 */
    .cell[data-has-rocket="true"] .wave-count {
      position: absolute;
      background: var(--rocket-counter-bg);
      color: white;
      padding: var(--rocket-counter-padding);
      border-radius: var(--rocket-counter-radius);
      font-size: var(--rocket-counter-font-size);
      font-weight: bold;
      border: var(--rocket-counter-border);
      z-index: 4;
      white-space: nowrap;
      transform: scale(var(--rocket-counter-scale));
      transform-origin: center;
    }

    .cell[data-has-rocket="true"] .wave-count:first-of-type {
      left: calc(-1 * var(--rocket-counter-offset-x));
      top: calc(-1 * var(--rocket-counter-offset-y));
    }

    .cell[data-has-rocket="true"] .wave-count:last-child {
      right: calc(-1 * var(--rocket-counter-offset-x));
      top: calc(-1 * var(--rocket-counter-offset-y));
    }

    /* 火箭等级效果 */
    .cell[data-rocket-level="1"] .cell-image {
      filter: brightness(var(--rocket-brightness-1));
    }

    .cell[data-rocket-level="2"] .cell-image {
      filter: brightness(var(--rocket-brightness-2));
    }

    .cell[data-rocket-level="3"] .cell-image {
      filter: brightness(var(--rocket-brightness-3));
    }

    .cell[data-rocket-level="4"] .cell-image {
      filter: brightness(var(--rocket-brightness-4));
    }

    .cell[data-rocket-level="5"] .cell-image {
      filter: brightness(var(--rocket-brightness-5));
    }

    .cell[data-has-rocket="true"]::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: var(--rocket-water-color);
      transition: height 0.5s ease-out;
      pointer-events: none;
      z-index: 2;
    }

    .cell[data-has-rocket="true"][data-pass-count="1"]::after { 
      height: var(--rocket-water-level-1); 
    }
    .cell[data-has-rocket="true"][data-pass-count="2"]::after { 
      height: var(--rocket-water-level-2); 
    }
    .cell[data-has-rocket="true"][data-pass-count="3"]::after { 
      height: var(--rocket-water-level-3); 
    }

    /* 胜利弹框样式 */
    .victory-dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      border: 3px solid #ff6b35;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      z-index: 10000;
      display: none;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .victory-dialog h2 {
      color: #ff6b35;
      font-size: 36px;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      font-weight: bold;
    }

    /* 天赋系统样式 */
    .talent-system {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      z-index: 10002;
      display: none;
      overflow: hidden;
    }

    .talent-header {
      position: absolute;
      top: 30px;
      right: 30px;
      z-index: 10003;
    }

    .talent-gold-display {
      display: flex;
      align-items: center;
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid #ffd700;
      border-radius: 22px;
      padding: 10px 15px;
    }

    .talent-gold-icon {
      width: 24px;
      height: 24px;
      margin-right: 8px;
    }

    .talent-gold-amount {
      color: #ffd700;
      font-size: 20px;
      font-weight: bold;
    }

    .talent-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: -50px;
      box-sizing: border-box;
      overflow-y: auto;
      transform: translateX(80px);
    }
    
    .talent-level-display {
      margin-bottom: 10px;
      text-align: center;
      width: 100%;
    }
    
    .talent-level-text {
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      padding: 5px 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      display: inline-block;
    }

    .talent-map {
      width: 278px;
      height: 240px;
      margin: 20px 0;
      border: 0;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .map-switch-button {
      position: absolute;
      width: 40px;
      height: 40px;
      background: none;
      border: none;
      cursor: pointer;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
    }
    
    .map-switch-button img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .map-switch-button:hover {
      transform: scale(1.1);
    }
    
    .map-switch-left:hover {
      transform: scaleX(-1) scale(1.1);
    }
    
    .map-switch-left {
      left: -50px;
      transform: scaleX(-1);
    }
    
    .map-switch-right {
      right: -50px;
    }

    .talent-map-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .start-game-button {
      padding: 15px 40px;
      font-size: 30px;
      color: #ffffff;
      font-weight: bold;
      background: linear-gradient(45deg, #ff6b6b, #ff8e53);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 20px 0;
    }

    .start-game-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #ff8e53, #ff6b6b);
    }

    .start-game-button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .talent-buttons {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 20px 0;
    }

    .talent-button {
      width: 160px;
      height: 280px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: 2px solid #ffd700;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 10px 5px;
      transition: all 0.3s ease;
      position: relative;
    }

    .talent-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }

    .talent-button img {
      width: 140px;
      height: 140px;
      object-fit: contain;
      z-index: 1;
      margin-top: 2px;
    }

    .talent-button-text {
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      z-index: 2;
      top: 150px;
    }

    .talent-cost {
      color: #ffd700;
      font-weight: bold;
      margin-top: 2px;
    }

    .talent-button.insufficient .talent-cost {
      color: #ff6b6b;
      margin-top: 2px;
    }

    .talent-button-icon {
      width: 40px;
      height: 40px;
      object-fit: contain;
      position: absolute;
      top: 150px;
      right: 10px;
    }

    /* 关卡完成奖励按钮样式 */
    .level-reward-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .level-reward-button {
      width: 160px;
      height: 80px;
      background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
      border: 2px solid #666;
      border-radius: 8px;
      cursor: not-allowed;
      display: flex;
      align-items: center;
      padding: 8px;
      transition: all 0.3s ease;
      opacity: 0.5;
      position: relative;
    }

    .level-reward-button.available {
      background: linear-gradient(135deg, #ffd700, #ffb347);
      border-color: #ffd700;
      cursor: pointer;
      opacity: 1;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .level-reward-button.available:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.7);
    }

    .level-reward-button.claimed {
      background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
      border-color: #333;
      cursor: not-allowed;
      opacity: 0.3;
    }

    .reward-icon {
      width: 32px;
      height: 32px;
      margin-right: 8px;
      object-fit: contain;
    }

    .reward-text {
      display: flex;
      flex-direction: column;
      color: white;
      font-size: 12px;
      line-height: 1.2;
    }

    .level-reward-button.available .reward-text {
      color: #333;
      font-weight: bold;
    }

    .reward-title {
      font-size: 20px;
      margin-bottom: 2px;
    }

    .reward-amount {
      font-size: 20px;
      color: #ffd700;
    }

    .level-reward-button.available .reward-amount {
      color: #b8860b;
    }

    .level-reward-button.claimed .reward-amount {
      color: #666;
    }

    /* 金币等级样式 */
    .gold-level {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      line-height: 1;
      position: absolute;
      bottom: 2px;
      right: 2px;
    }
  </style>
<style>/* stylelint-disable */
/* stylelint-enable */
/** Buttons
---------------------------------------------------------*/
:root {
  --transparent: rgba(255, 255, 255, 0);
  --white: hsl(0, 0%, 100%);
  --th-white: hsl(0, 0%, 100%);
  --black: hsl(0, 0%, 0%);
  --th-black: hsl(0, 0%, 0%);
  --lightGrey: hsl(0, 0%, 94%);
  --th-grey-white: hsl(210, 10%, 97%);
  --th-grey-light: hsl(210, 10%, 94.8%);
  --th-grey-medium: hsl(212, 10%, 94%);
  --th-grey: hsl(216, 22%, 91%);
  --th-grey-dark: hsl(221, 20%, 78%);
  --th-slate: hsl(221, 20%, 33%);
  --th-slate-light: hsl(222, 20%, 45%);
  --th-slate-dark: hsl(222, 22%, 18%);
  --th-slate-alt: #333F57;
  --th-slate-hover:#3E4A62;
  --th-slate-dark-hover800:hsl(220, 22%, 24%);
  --th-slate-dark-active800:hsl(219, 24%, 26%);
  --th-slate-dark-hover600:hsl(222, 22%, 21%);
  --th-slate-dark-active600:hsl(221, 24%, 23%);
  --th-cool-grey-600: hsl(203, 16%, 44%);
  --th-cool-grey-700: hsl(204, 18%, 30%);
  --th-cool-grey-750: hsl(203, 18%, 32%);
  --th-cool-grey-800: hsl(209, 20%, 25%);
  --th-cool-grey-850: hsl(209, 20%, 21%);
  --th-cool-grey-900: hsl(210, 24%, 16%);
  --fontColorDark: var( --th-slate-dark);
  --fontColorWhite: hsl(0, 0%, 100%);
  --list-item-hover:hsl(225, 20%, 96%);
  --list-item-light-hover: hsl(210, 20%, 98%);
  --list-item-hover-dark:hsla(222, 22%, 18%, 0.50);
  --list-item-light-hover-dark: hsla(222, 20%, 33%, 0.50);
  --greyTransparent: hsla(222, 22%, 18%, 0.12);
  --whiteTransparent: hsla(0, 0%, 100%, 0.12);
  --defaultColor: hsl(220, 20%, 91%);
  --defaultColorHover: hsl(220, 19%, 78%);
  --defaultColorActive: hsl(220, 19%, 68%);
  --defaultColorSelected: hsl(221, 20%, 75%);
  --buttonBorderColor: 2px solid hsl(220, 20%, 91%);
  --buttonBorderColorHover: 2px solid hsl(220, 19%, 78%);
  --buttonBorderColorActive: 2px solid hsl(220, 19%, 68%);
  --buttonBorderColorSelected: 2px solid hsl(221, 20%, 75%);
  --iconFillColor: var( --th-slate-dark );
  --primaryColor: hsl(211, 100%, 45%);
  --primaryColorHover: hsl(211, 100%, 35%);
  --primaryColorActive: hsl(211, 100%, 25%);
  --primaryButtonBorder: 2px solid hsl(211, 100%, 45%);
  --primaryButtonBorderHover: 2px solid hsl(211, 100%, 35%);
  --primaryButtonBorderActive: 2px solid hsl(211, 100%, 25%);
  --secondaryColor: var(--th-slate);
  --secondaryColorHover: hsl(221, 20%, 23%);
  --secondaryColorActive: hsl(221, 20%, 13%);
  --secondaryButtonBorderColor: 2px solid var(--th-slate);
  --secondaryButtonBorderColorHover: 2px solid hsl(221, 20%, 23%);
  --secondaryButtonBorderColorActive: 2px solid hsl(221, 20%, 13%);
  --disabledColor: hsl(0, 0%, 50%);
  --disabledBackgroundColor: hsl(0, 0%, 95%);
  --brandColorGreen: hsl(76, 60%, 52%);
  --brandColorGreenActive: hsl(76, 62%, 40%);
  --primaryColorGreen: hsl(79, 100%, 24%);
  --primaryColorGreenHover: hsl(79, 100%, 14%);
  --primaryColorGreenActive: hsl(79, 100%, 4%);
  --buttonBorderGreen: 2px solid hsl(79, 100%, 24%);
  --buttonBorderGreenHover: 2px solid hsl(79, 100%, 14%);
  --buttonBorderGreenActive: 2px solid hsl(79, 100%, 4%);
  --brandColorPink: hsl(344, 98%, 59%);
  --primaryColorPink: #e12362;
  --primaryColorPinkHover: hsl(340, 76%, 41%);
  --primaryColorPinkActive: hsl(340, 76%, 31%);
  --buttonBorderPink: 2px solid hsl(340, 76%, 51%);
  --buttonBorderPinkHover: 2px solid hsl(340, 76%, 41%);
  --buttonBorderPinkActive: 2px solid hsl(340, 76%, 31%);
  --brandColorTeal: hsl(180, 85%, 34%);
  --primaryColorTeal: hsl(184, 50%, 35%);
  --primaryColorTealHover: hsl(184, 50%, 25%);
  --primaryColorTealActive: hsl(184, 50%, 15%);
  --buttonBorderTeal: 2px solid hsl(184, 50%, 35%);
  --buttonBorderTealHover: 2px solid hsl(184, 50%, 25%);
  --buttonBorderTealActive: 2px solid hsl(184, 50%, 15%);
  --brandColorPurple: hsl(264, 100%, 68%);
  --primaryColorPurple: hsl(264, 83%, 62%);
  --primaryColorPurpleHover: hsl(264, 83%, 52%);
  --primaryColorPurpleActive: hsl(264, 83%, 42%);
  --buttonBorderPurple: 2px solid hsl(264, 83%, 62%);
  --buttonBorderPurpleHover: 2px solid hsl(264, 83%, 52%);
  --buttonBorderPurpleActive: 2px solid hsl(264, 83%, 42%);
  --brandColorOrange: hsl(33, 94%, 48%);
  --primaryColorOrange: hsl(15, 79%, 45%);
  --primaryColorOrangeHover: hsl(15, 80%, 35%);
  --primaryColorOrangeActive: hsl(15, 80%, 25%);
  --buttonBorderOrange: 2px solid hsl(15, 79%, 45%);
  --buttonBorderOrangeHover: 2px solid hsl(15, 80%, 35%);
  --buttonBorderOrangeActive: 2px solid hsl(15, 80%, 25%);
  --brandColorBlue: hsl(197, 100%, 50%);
  --brandColorBlueActive: hsl(197, 100%, 39%);
  --brandColorBlueWCAG: hsl(197, 100%, 42%);
  --primaryColorBlue: hsl(201, 100%, 37%);
  --primaryColorBlueHover: hsl(201, 100%, 27%);
  --primaryColorBlueActive: hsl(201, 100%, 17%);
  --buttonBorderBlue: 2px solid hsl(201, 100%, 37%);
  --buttonBorderBlueHover: 2px solid hsl(201, 100%, 27%);
  --buttonBorderBlueActive: 2px solid hsl(201, 100%, 17%);
  --BrandcolorYellow: hsl(41, 90%, 61%);
  --primaryColorReachDeck: hsl(209, 100%, 39%);
  --primaryColorReachDeckHover: hsl(209, 100%, 29%);
  --primaryColorReachDeckActive: hsl(209, 100%, 19%);
  --buttonBorderReachDeck: 2px solid hsl(209, 100%, 39%);
  --buttonBorderReachDeckHover: 2px solid hsl(209, 100%, 29%);
  --buttonBorderReachDeckActive: 2px solid hsl(209, 100%, 19%);
  --reachDeckEditorColor: hsl(112, 100%, 26%);
  --launchpadButtonLight: hsl(210, 10%, 96%);
  --launchpadButtonLightHover: hsl(220, 8%, 92%);
  --launchpadButtonLightActive:hsl(0, 0%, 90%);
  --ContrastPinkOrbitNoteHover: hsl(343, 81%, 48%);
  --ContrastPinkOrbitNoteActive: hsl(345, 96%, 42%);
  --ContrastButtonBorderPink: hsl(345, 96%, 42%);
  --primaryColorClaroNavy: hsl(207, 74%, 27%);
  --primaryColorClaroNavyHover: hsl(206, 83%, 21%);
  --primaryColorClaroNavyActive: hsl(206, 89%, 17%);
  --buttonBorderClaro: 2px solid hsl(207, 74%, 27%);
  --buttonBorderClaroHover: 2px solid hsl(206, 83%, 21%);
  --buttonBorderClaroActive: 2px solid hsl(206, 89%, 17%);
  --primaryColorClaroBlue: hsl(201, 100%, 37%);
  --primaryColorClaroBlueHover: hsl(201, 100%, 31%);
  --primaryColorClaroBlueActive: hsl(201, 100%, 27%);
  --claroDark: hsl(218, 54%, 20%);
  --claroGrey: hsl(217, 31%, 68%);
  --claroBlue: hsl(191, 88%, 40%);
  --claroBlueAlt: hsl(188, 78%, 50%);
  --claroGreen: hsl(75, 63%, 51%);
  --altColor: var(--claroGreen);
  --altColorHover: hsl(75, 70%, 40%);
  --altColorActive: hsl(75, 77%, 33%);
  --altButtonBorderColor: 2px solid var(--claroGreen);
  --altButtonBorderColorHover: 2px solid hsl(75, 70%, 40%);
  --altButtonBorderColorActive: 2px solid hsl(75, 77%, 33%);
  --brandColorLingdys: hsl(0, 82%, 49%);
  --primaryColorLingdys: hsl(217, 34%, 38%);
  --primaryColorLingdysHover: hsl(217, 37%, 24%);
  --primaryColorLingdysActive: hsl(217, 39%, 18%);
  --buttonBorderLingdys: 2px solid hsl(217, 34%, 38%);
  --buttonBorderLingdysHover: 2px solid hsl(217, 37%, 24%);
  --buttonBorderLingdysActive: 2px solid hsl(217, 39%, 18%);
  --brandColorAppWriter: #F70790;
  --primaryColorAppWriter: #D8087F;
  --primaryColorAppWriterHover:#B40669;
  --primaryColorAppWriterActive: #9F055C;
  --buttonBorderAppwriter: 2px solid #D8087F;
  --buttonBorderAppwriterHover: 2px solid #B40669;
  --buttonBorderAppWriterActive: 2px solid #9F055C;
  --iconToggleFillOrbitNote: hsl(196, 99%, 50%);
  --textColor: var( --th-slate-dark );
  --textColorLight: var( --th-white );
  --border: 1px solid var( --th-grey );
  --borderDark: 1px solid var( --th-grey-dark );
  --infoColor: hsl(194, 77%, 24%);
  --successColor: hsla(134, 71%, 43%, 0.584);
  --errorColor: hsl(0, 71%, 51%);
  --warningColor: hsl(45, 97%, 51%);
  --infoBackgroundColor: hsl(180, 100%, 99%);
  --successBackgroundColor: hsl(78, 100%, 98%);
  --errorBackgroundColor: hsl(0, 100%, 98%);
  --warningBackgroundColor: hsl(35, 100%, 98%);
  --notificationDarkModeBackground: hsl(218, 22%, 37%);
  --infoBorderColor: hsl(191, 44%, 82%);
  --successBorderColor: hsl(100, 28%, 69%);
  --errorBorderColor: hsl(0, 37%, 73%);
  --warningBorderColor: hsl(41, 30%, 71%);
  --notificationDarkModeBorder: hsl(217, 19%, 41%);
  --infoTitleColor: hsl(194, 77%, 24%);
  --successTitleColor: hsl(121, 48%, 23%);
  --errorTitleColor: hsl(1, 47%, 40%);
  --warningTitleColor: hsl(37, 92%, 25%);
  --infoWarningColor: hsl(194, 77%, 24%);
  --successWarningColor: hsla(121, 48%, 23%, 0.8);
  --errorWarningColor: hsla(1, 47%, 40%, 0.8);
  --warningWarningColor: hsla(37, 92%, 25%, 0.8);
  --line-height-base: 1.5;
  --zindex-modal: 1050;
  --modal-dialog-margin: 2rem;
  --modal-content-border-radius: 1px;
  --buttonBorderRadius: 30px;
  --buttonRoundness: 30px;
  --buttonLinkTextColor: var( --primaryColor)!important;
  --buttonLinkIconColor: var( --primaryColor)!important;
  --buttonNoBackgroundTextColor: var( --th-slate-dark);
  --buttonNoBackgroundIconColor: var( --th-slate-dark);
  --buttonNoBackgroundColor: transparent;
  --buttonNoBackgroundColorHover: var(--icon-button-background-hover-color);
  --buttonNoBackgroundColorActive: var(--icon-button-background-active-color);
  --buttonNoBackgroundBorder: 2px solid transparent;
  --buttonNoBackgroundBorderHover: 2px solid transparent;
  --buttonNoBackgroundBorderActive: 2px solid transparent;
  --activeDotColor: inherit;
  --themeColorDefault: var(--defaultColor);
  --themeColorGroundworks: var(--primaryColor);
  --themeColorReadWrite: var(--primaryColorPurple);
  --themeColorEquatio: var(--primaryColorBlue);
  --themeColorBrowsealoud: var(--primaryColorOrange);
  --themeColorWriq: var(--primaryColorTeal);
  --themeColorFluencyTutor: var(--primaryColorGreen);
  --themeColorSnapVerter: var(--primaryColorGreen);
  --themeColorSpeechStream: var(--primaryColorPink);
  --themeColorTexthelp: var(--primaryColorTeal);
  --themeColorReachDeck: var(--primaryColorReachDeck);
  --themeColorPdfReader: var(--primaryColorBlue);
  --uniloginBackgroundColor: #F7F7F7;
  --uniloginWindowBackgroundColor: var(--primaryColorBlue);
  --line-height-base: 1.5;
  --zindex-modal: 1050;
  --modal-dialog-margin: 2em;
  --modal-content-border-radius: 1px;
  --modal-inner-padding: 1.5em;
  --modal-title-padding: 1.5em;
  --modal-title-line-height: var(--line-height-base);
  --modal-content-bg: #fff;
  --modal-content-border-color: rgba(0, 0, 0, .2);
  --modal-content-fallback-border-color: #999;
  --modal-backdrop-bg: #000;
  --modal-backdrop-opacity: .5;
  --modal-header-border-color: #e5e5e5;
  --modal-footer-border-color: var(--modal-header-border-color);
  --modal-header-background-color: #f5f5f5;
  --select-border: 1px solid #DADADA;
  --select-background: hsl(0, 0%, 100%);
  --select-background-color: #efefef;
  --select-background-color-hover: hsl(0, 0%, 97%);
  --input-border: 1px solid #DADADA;
  --input-background-color: #ffffff;
  --settings-title-color: var(--primaryColor);
  --settings-item-background-color: var(--th-white);
  --settings-item-background-hover-color: var(--th-grey-medium);
  --settings-item-background-active-color: var(--th-grey);
  --list-group-background-color: transparent;
  --list-group-item-background-color: var(--th-white);
  --list-group-item-background-hover-color: var(--th-grey-light);
  --list-group-item-background-active-color: var(--th-grey);
  --list-group-item-icon-color: var(--th-slate-dark);
  --ListGroupSearchItemColor: var(--th-white);
  --ListGroupSearchItemColorHover: #f9fafb;
  --ListGroupSearchItemTextColor: var(--th-slate);
  --ListGroupSearchItemBorderColor: hsla(0, 0%, 0%, 0.15);
  --ListGroupSearchItemAsideColor: hsl(0, 0%, 95%);
  --ListGroupSearchItemAsideTextColor: #000;
  --toolbar-button-disabled: hsl(0, 0%, 96.1%);
  --toolbar-button-background: hsl(0, 0%, 96.1%);
  --toolbar-button-hover-background: hsl(0, 0%, 80%);
  --toolbar-button-color: hsl(0, 0%, 0%);
  --toolbar-button-hover-active-background: hsl(0, 0%, 70.2%);
  --toolbar-button-default-size: 43px;
  --toolbar-button-focus-color: hsl(213, 71.3%, 60.4%);
  --toolbar-button-svg-color: hsl(0, 0%, 29%);
  --toolbar-button-toggle-color: hsl(264, 100%, 68%);
  --panel-inner-padding: .7em;
  --icon-button-background-default-color: hsla(0, 0%, 0%, 0.077);
  --icon-button-background-hover-color: hsla(0, 0%, 0%, 0.125);
  --icon-button-background-active-color: hsla(0, 0%, 0%, 0.187);
  --icon-button-background-default-color-dark: rgba(255, 255, 255, 0.077);
  --icon-button-background-hover-color-dark: rgba(255, 255, 255, 0.146);
  --icon-button-background-active-color-dark: rgba(255, 255, 255, 0.221);
  --icon-button-border-color: solid 2px transparent;
  --menuIconFillColor: var(--th-slate);
  --cardIconFillColor: var(--th-slate);
  --default-menu-notify-background-colour: hsl(264, 100%, 68%);
  --toolbarButtonBackgroundColor: var( --defaultColor);
  --toolbarButtonBackgroundHoverColor: var( --icon-button-background-hover-color);
  --toolbarButtonBackgroundActiveColor: var( --icon-button-background-active-color);
  --toolbarIconHoverFill: var( --th-slate);
  --toolbarIconToggleFill: var( --primaryColor);
  --dashboardContentBackgroundColor: #fff;
  --dashboardHeaderBackgroundColor: #fff;
  --dashboardSidebarBorderTopColor: var( --lightGrey);
  --dashboardTextColor: var(--th-slate);
  --dashboardTitleTextColor: var(--fontColorDark);
  --dashboardSubTitleTextColor: var(--th-slate-light);
  --dashboardCardBackgroundColor: var(--white);
  --dashboardCardBackgroundHoverColor: var(--th-grey-light);
  --dashboardCardBackgroundActiveColor: var(--lightGrey);
  --dashboardCardHighlightColor: var(--primaryColor);
  --dashboardCardBorderColor: var(--lightGrey);
  --dashboardCardFooterLinkColor: var(--primaryColor);
  --dashboardCardAuditorColor: hsl(208, 100%, 43%);
  --dashboardCardAuditorLabelColor: hsl(208, 100%, 43%);
  --dashboardCardEditorLabelColor: var(--reachDeckEditorColor);
  --dashboardCardToolbarColor: var(--primaryColorOrange);
  --dashboardCardToolbarLabelColor: var(--primaryColorOrange);
  --dashboardPaneBackgroundColor: #fcfcfc;
  --dashboardPaneBorderColor: rgba(92, 106, 138, 0.4);
  --dashboardPaneDashedBorderColor: var(--dashboardDashedBorderLight);
  --dashboardDashedBorderLight: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' stroke='%235C6A8ACC' stroke-width='2' stroke-dasharray='4%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
  --dashboardDashedBorderDark: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' stroke='%23323E52FF' stroke-width='2' stroke-dasharray='4%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
  --icon-opacity: 1;
  --accordionBackgroundColor: #fff;
  --accordionTextColor: #484848;
  --accordionTextBottomColor: #484848;
  --accordionIconColor: var(--toolbarWhite);
  --accordionBackgroundColorHover: #f9fafb;
  --tableBackgroundColor: none;
  --tableBackgroundHeaderColor: #F9FAFB;
  --tableBackgroundAltColor: #f7f7f7;
  --tableBackgroundHoverColor: hsl(210, 20%, 98%);
  --tableBorderColor: #E2E2E3;
  --tableTextColor: #484848;
}

/* stylelint-disable */
/* stylelint-enable */
.th-wq,
.th-th {
  --toolbarBackgroundColor: var(--defaultColor);
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorWriq);
  --themeColorSecondary: var(--secondaryColor);
  --dashboardTopColor: var(--brandColorTeal);
  --dashboardTitleColor: var(--themeColorWriq);
  --iconFillColor: var(--white);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorTeal);
  --primaryButtonBackgroundHoverColor: var(--primaryColorTealHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorTealActive);
  --primaryButtonBorderActive: var(--buttonBorderTealActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderTeal);
  --primaryButtonBorderHover: var(--buttonBorderTealHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
}

.th-rw,
.th-wa {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorReadWrite);
  --themeColorSecondary: var(--secondaryColor);
  --toolbarBackgroundColor: var(--defaultColor);
  --toolbarIconFill: var(--th-slate);
  --toolbarIconHoverFill: var(--th-slate);
  --toolbarIconActiveFill: var(--th-slate);
  --toolbarIconToggledHoverFill: var(--primaryColorPurple);
  --toolbarIconToggleFill: var(--primaryColorPurple);
  --toolbarIconToggleHoverFill: var(--primaryColorPurple);
  --dashboardTopColor: var(--brandColorPurple);
  --dashboardTitleColor: var(--themeColorReadWrite);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderActive: var(--buttonBorderColorActive);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorPurple);
  --primaryButtonBackgroundHoverColor: var(--primaryColorPurpleHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorPurpleActive);
  --primaryButtonBorderActive: var(--buttonBorderPurpleActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderPurple);
  --primaryButtonBorderHover: var(--buttonBorderPurpleHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
  --menuNotifyBackgroundColour: var(--brandColorPurple);
  --uniloginBackgroundColor: #FAF7FF;
  --uniloginWindowBackgroundColor: var(--primaryColorPurple);
}

.th-pr {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorPdfReader);
  --themeColorSecondary: var(--secondaryColor);
  --primaryButtonBackgroundColor: var(--primaryColorBlue);
  --primaryButtonBackgroundHoverColor: var(--primaryColorBlueHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorBlueActive);
  --primaryButtonBorderActive: var(--buttonBorderBlueActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderBlue);
  --primaryButtonBorderHover: var(--buttonBorderBlueHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --toolbarBackgroundColor: var(--th-grey);
  --toolbarButtonBackgroundColor: var(--th-grey);
  --toolbarButtonBackgroundHoverColor: var(--ContrastPinkOrbitNoteHover);
  --toolbarButtonBackgroundActiveColor: var(--ContrastPinkOrbitNoteActive);
  --toolbarButtonBorderActive: var(--ContrastButtonBorderPink);
  --toolbarIconFill: var(--th-slate);
  --toolbarIconHoverFill: var(--white);
  --toolbarIconActiveFill: var(--white);
  --toolbarIconToggleFill: var(--ContrastPinkOrbitNoteActive);
  --toolbarIconToggleHoverFill: var(--white);
  --toolbarIconToggledHoverFill: var(--white);
  --iconButtonBackgroundDefaultColor: var(--icon-button-background-default-color);
  --iconButtonBackgroundHoverColor: var(--icon-button-background-hover-color);
  --iconButtonBackgroundActiveColor: var(--icon-button-background-active-color);
  --iconButtonBorderColor: 2px solid transparent;
  --iconFillColor: var(--th-slate);
  --panelBackgroundColor: var(--th-grey-light);
  --panelBackgroundColorLight: var(--white);
  --panelBackgroundColorDark: var(--th-grey);
  --fontColor: var(--th-slate-dark);
  --borderColor: 1px solid var(--th-grey-dark);
  --settingsTitleColor: var(--themeColorPrimary);
  --menuNotifyBackgroundColour: var(--brandColorPink);
  --dashboardTopColor: var(--primaryColorBlue);
  --dashboardTitleColor: var(--themeColorEquatio);
  --cardIconFillColor: var(--primaryColorBlue);
}

.th-eq {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorEquatio);
  --themeColorSecondary: var(--secondaryColor);
  --dashboardTopColor: var(--brandColorBlue);
  --dashboardTitleColor: var(--themeColorEquatio);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorBlue);
  --primaryButtonBackgroundHoverColor: var(--primaryColorBlueHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorBlueActive);
  --primaryButtonBorderActive: var(--buttonBorderBlueActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderBlue);
  --primaryButtonBorderHover: var(--buttonBorderBlueHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
  --uniloginBackgroundColor: #F2F9FF;
  --uniloginWindowBackgroundColor: var(--brandColorBlueWCAG);
}

.th-ba {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorBrowsealoud);
  --themeColorSecondary: var(--secondaryColor);
  --toolbarBackgroundColor: var(--th-grey);
  --toolbarIconButtonFillColor: var(--th-slate);
  --toolbarButtonBackgroundColor: var(--th-grey);
  --toolbarButtonBackgroundHoverColor: var(--primaryColorOrangeHover);
  --toolbarButtonBackgroundActiveColor: var(--primaryColorOrangeActive);
  --toolbarButtonBorderActive: var(--buttonBorderOrange);
  --toolbarIconFill: var(--th-slate);
  --toolbarIconHoverFill: var(--th-slate);
  --toolbarIconActiveFill: var(--primaryColorBlue);
  --toolbarIconToggleFill: var(--primaryColorBlue);
  --toolbarIconToggleHoverFill: var(--white);
  --dashboardTopColor: var(--brandColorOrange);
  --dashboardTitleColor: var(--themeColorBrowsealoud);
  --iconFillColor: var(--white);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorOrange);
  --primaryButtonBackgroundHoverColor: var(--primaryColorOrangeHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorOrangeActive);
  --primaryButtonBorderActive: var(--buttonBorderOrangeActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderOrange);
  --primaryButtonBorderHover: var(--buttonBorderOrangeHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
  --menuNotifyBackgroundColour: var(--white);
}
.th-ba .gw-menu-notification--inline {
  --menuNotifyBackgroundColour: var(--themeColorBrowsealoud);
}

.th-at {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorReachDeck);
  --themeColorSecondary: var(--secondaryColor);
  --toolbarBackgroundColor: var(--defaultColor);
  --toolbarIconFill: var(--th-slate);
  --toolbarIconHoverFill: var(--th-slate);
  --toolbarIconActiveFill: var(--th-slate);
  --toolbarIconToggledHoverFill: var(--primaryColorBlue);
  --toolbarIconToggleFill: var(--primaryColorBlue);
  --toolbarIconToggleHoverFill: var(--primaryColorBlue);
  --dashboardTopColor: var(--th-grey);
  --dashboardTitleColor: var(--th-slate-dark);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorReachDeck);
  --primaryButtonBackgroundHoverColor: var(--primaryColorReachDeckHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorReachDeckActive);
  --primaryButtonBorderActive: var(--buttonBorderReachDeckActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderReachDeck);
  --primaryButtonBorderHover: var(--buttonBorderReachDeckHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --dashboardTopColor: #E12362;
  --dashboardContentBackgroundColor: #F2F5F9;
  --tableBackgroundHeaderColor: #DFE1E5;
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
}

.th-rd {
  font-size: 10px;
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorReachDeck);
  --themeColorSecondary: var(--secondaryColor);
  --toolbarBackgroundColor: var(--defaultColor);
  --toolbarIconFill: var(--th-slate);
  --toolbarIconHoverFill: var(--th-slate);
  --toolbarIconActiveFill: var(--th-slate);
  --toolbarIconToggledHoverFill: var(--primaryColorBlue);
  --toolbarIconToggleFill: var(--primaryColorBlue);
  --toolbarIconToggleHoverFill: var(--primaryColorBlue);
  --dashboardTopColor: var(--th-grey);
  --dashboardTitleColor: var(--th-slate-dark);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorReachDeck);
  --primaryButtonBackgroundHoverColor: var(--primaryColorReachDeckHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorReachDeckActive);
  --primaryButtonBorderActive: var(--buttonBorderReachDeckActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderReachDeck);
  --primaryButtonBorderHover: var(--buttonBorderReachDeckHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
}

.th-ss {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorSpeechStream);
  --themeColorSecondary: var(--secondaryColor);
  --dashboardTopColor: var(--brandColorPink);
  --dashboardTitleColor: var(--themeColorSpeechStream);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--themeColorSpeechStream);
  --primaryButtonBackgroundHoverColor: var(--primaryColorPinkHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorPinkActive);
  --primaryButtonBorderActive: var(--buttonBorderPinkActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderPink);
  --primaryButtonBorderHover: var(--buttonBorderPinkHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
}

.th-st {
  --uniloginBackgroundColor: #F2F9FF;
  --uniloginWindowBackgroundColor: #2A3953;
}

.th-sv,
.th-ft {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--themeColorFluencyTutor);
  --themeColorSecondary: var(--secondaryColor);
  --dashboardTopColor: var(--brandColorGreen);
  --dashboardTitleColor: var(--themeColorFluencyTutor);
  --iconFillColor: var(--th-slate-dark);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--themeColorFluencyTutor);
  --primaryButtonBackgroundHoverColor: var(--primaryColorGreenHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorGreenActive);
  --primaryButtonBorderActive: var(--buttonBorderGreenActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderGreen);
  --primaryButtonBorderHover: var(--buttonBorderGreenHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --secondaryButtonBackgroundColor: var(--secondaryColor);
  --secondaryButtonBackgroundHoverColor: var(--secondaryColorHover);
  --secondaryButtonBackgroundActiveColor: var(--secondaryColorActive);
  --secondaryButtonTextColor: var(--fontColorWhite);
  --secondaryButtonTextHoverColor: var(--fontColorWhite);
  --secondaryButtonTextActiveColor: var(--fontColorWhite);
  --secondaryButtonTextVisitedColor: var(--fontColorWhite);
  --secondaryButtonBorder: var(--secondaryButtonBorder);
  --secondaryButtonBorderHover: var(--secondaryButtonBorderColorHover);
  --secondaryButtonBorderRadius: var(--buttonRoundness);
  --secondaryButtonIconFillColor: var(--white);
  --table-hover-item: var(--list-item-light-hover);
  --settingsTitleColor: var(--themeColorPrimary);
}

.th-cr {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--primaryColorClaroNavy);
  --themeColorSecondary: var(--secondaryColor);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorClaroNavy);
  --primaryButtonBackgroundHoverColor: var(--primaryColorClaroNavyHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorClaroNavyActive);
  --primaryButtonBorderActive: var(--buttonBorderClaroActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderClaro);
  --primaryButtonBorderHover: var(--buttonBorderClaroHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --altButtonBackgroundColor: var(--altColor);
  --altButtonBackgroundHoverColor: var(--altColorHover);
  --altButtonBackgroundActiveColor: var(--altColorActive);
  --altButtonTextColor: var(--fontColorWhite);
  --altButtonTextHoverColor: var(--fontColorWhite);
  --altButtonTextActiveColor: var(--fontColorWhite);
  --altButtonTextVisitedColor: var(--fontColorWhite);
  --altButtonBorder: var(--altButtonBorder);
  --altButtonBorderHover: var(--altButtonBorderColorHover);
  --altButtonBorderRadius: var(--buttonRoundness);
  --altButtonIconFillColor: var(--white);
  --uniloginBackgroundColor: #F2F9FF;
  --uniloginWindowBackgroundColor: var(--themeColorPrimary);
}

.th-wh {
  background: #F6F6F6;
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--primaryColorClaroNavy);
  --themeColorSecondary: var(--secondaryColor);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorClaroBlue);
  --primaryButtonBackgroundHoverColor: var(--primaryColorClaroBlueHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorClaroBlueActive);
  --primaryButtonBorderActive: var(--buttonBorderClaroActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--primaryColorClaroBlue);
  --primaryButtonBorderHover: var(--primaryColorClaroBlueHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --altButtonBackgroundColor: var(--altColor);
  --altButtonBackgroundHoverColor: var(--altColorHover);
  --altButtonBackgroundActiveColor: var(--altColorActive);
  --altButtonTextColor: var(--fontColorWhite);
  --altButtonTextHoverColor: var(--fontColorWhite);
  --altButtonTextActiveColor: var(--fontColorWhite);
  --altButtonTextVisitedColor: var(--fontColorWhite);
  --altButtonBorder: var(--altButtonBorder);
  --altButtonBorderHover: var(--altButtonBorderColorHover);
  --altButtonBorderRadius: var(--buttonRoundness);
  --altButtonIconFillColor: var(--white);
  --uniloginBackgroundColor: #F2F9FF;
  --uniloginWindowBackgroundColor: var(--primaryColorClaroNavy);
}

.th-lds {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--primaryColorLingdys);
  --themeColorSecondary: var(--secondaryColor);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorLingdys);
  --primaryButtonBackgroundHoverColor: var(--primaryColorLingdysHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorLingdysActive);
  --primaryButtonBorderActive: var(--buttonBorderLingdysActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderLingdys);
  --primaryButtonBorderHover: var(--buttonBorderLingdysHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --altButtonBackgroundColor: var(--altColor);
  --altButtonBackgroundHoverColor: var(--altColorHover);
  --altButtonBackgroundActiveColor: var(--altColorActive);
  --altButtonTextColor: var(--fontColorWhite);
  --altButtonTextHoverColor: var(--fontColorWhite);
  --altButtonTextActiveColor: var(--fontColorWhite);
  --altButtonTextVisitedColor: var(--fontColorWhite);
  --altButtonBorder: var(--altButtonBorder);
  --altButtonBorderHover: var(--altButtonBorderColorHover);
  --altButtonBorderRadius: var(--buttonRoundness);
  --altButtonIconFillColor: var(--white);
  --uniloginBackgroundColor: #F2F9FF;
  --uniloginWindowBackgroundColor: var(--themeColorPrimary);
}

.th-aw {
  --themeColorDefault: var(--defaultColor);
  --themeColorPrimary: var(--primaryColorClaroNavy);
  --themeColorSecondary: var(--secondaryColor);
  --buttonBackgroundColor: var(--defaultColor);
  --buttonBackgroundHoverColor: var(--defaultColorHover);
  --buttonBackgroundActiveColor: var(--defaultColorActive);
  --buttonTextColor: var(--fontColorDark);
  --buttonTextHoverColor: var(--fontColorDark);
  --buttonTextActiveColor: var(--fontColorDark);
  --buttonTextVisitedColor: var(--fontColorDark);
  --buttonBorder: var(--buttonBorder);
  --buttonBorderHover: var(--buttonBorderColorHover);
  --buttonBorderRadius: var(--buttonRoundness);
  --buttonBorderIconFillColor: var(--black);
  --primaryButtonBackgroundColor: var(--primaryColorAppWriter);
  --primaryButtonBackgroundHoverColor: var(--primaryColorAppWriterHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorAppWriterActive);
  --primaryButtonBorderActive: var(--buttonBorderAppWriterActive);
  --primaryButtonTextColor: var(--fontColorWhite);
  --primaryButtonTextHoverColor: var(--fontColorWhite);
  --primaryButtonTextActiveColor: var(--fontColorWhite);
  --primaryButtonTextVisitedColor: var(--fontColorWhite);
  --primaryButtonBorder: var(--buttonBorderAppWriter);
  --primaryButtonBorderHover: var(--buttonBorderAppWriterHover);
  --primaryButtonBorderRadius: var(--buttonRoundness);
  --primaryButtonIconFillColor: var(--white);
  --altButtonBackgroundColor: var(--altColor);
  --altButtonBackgroundHoverColor: var(--altColorHover);
  --altButtonBackgroundActiveColor: var(--altColorActive);
  --altButtonTextColor: var(--fontColorWhite);
  --altButtonTextHoverColor: var(--fontColorWhite);
  --altButtonTextActiveColor: var(--fontColorWhite);
  --altButtonTextVisitedColor: var(--fontColorWhite);
  --altButtonBorder: var(--altButtonBorder);
  --altButtonBorderHover: var(--altButtonBorderColorHover);
  --altButtonBorderRadius: var(--buttonRoundness);
  --altButtonIconFillColor: var(--white);
  --uniloginBackgroundColor: #F7F7F7;
  --uniloginWindowBackgroundColor: var(--primaryColorAppWriter);
}

.dark-mode {
  --toolbarBackgroundColor: var(--th-slate-dark);
  --toolbarButtonBackgroundColor: var(--th-slate-dark);
  --toolbarButtonBackgroundHoverColor: var(--icon-button-background-hover-color-dark);
  --toolbarButtonBackgroundActiveColor: var(--icon-button-background-active-color-dark);
  --toolbarButtonBorderActive: var(--buttonBorderPink);
  --toolbarIconFill: var(--white);
  --toolbarIconHoverFill: var(--white);
  --toolbarIconActiveFill: var(--white);
  --dashboardHeaderBackgroundColor: var(--th-slate-dark);
  --dashboardSidebarBorderTopColor: var(--th-slate);
  --dashboardSidebarBackgroundColor: var(--th-slate-dark);
  --dashboardContentBackgroundColor: var(--th-slate);
  --dashboardCardBackgroundColor: var(--th-slate-dark);
  --dashboardCardBackgroundHoverColor: var(--th-slate-dark-hover600);
  --dashboardCardBackgroundActiveColor: var(--th-slate-dark-active600);
  --dashboardCardHighlightColor: var(--brandColorBlue);
  --dashboardTextColor: var(--th-white);
  --dashboardTitleTextColor: var(--th-white);
  --dashboardSubTitleTextColor: var(--th-white);
  --menuIconFillColor: var(--white);
  --iconButtonBackgroundDefaultColor: var(--icon-button-background-default-color-dark);
  --iconButtonBackgroundHoverColor: var(--icon-button-background-hover-color-dark);
  --iconButtonBackgroundActiveColor: var(--icon-button-background-active-color-dark);
  --iconButtonBorderColor: 2px solid transparent;
  --iconFillColor: var(--white);
  --buttonLinkTextColor: var(--white);
  --buttonLinkIconColor: var(--white);
  --buttonNoBackgroundTextColor: var(--white);
  --buttonNoBackgroundIconColor: var(--white);
  --buttonNoBackgroundColor: transparent;
  --buttonNoBackgroundColorHover: var(--icon-button-background-hover-color-dark);
  --buttonNoBackgroundColorActive: var(--icon-button-background-active-color-dark);
  --buttonNoBackgroundBorder: 2px solid transparent;
  --buttonNoBackgroundBorderHover: 2px solid transparent;
  --buttonNoBackgroundBorderActive: 2px solid transparent;
  --panelBackgroundColor: var(--th-slate);
  --panelBackgroundColorLight: var(--th-slate-light);
  --panelBackgroundColorDark: var(--th-slate-dark);
  --fontColor: var(--textColorLight);
  --borderColor: 1px solid var(--th-slate-light);
  --infoBackgroundColor: var(--notificationDarkModeBackground);
  --successBackgroundColor: var(--notificationDarkModeBackground);
  --errorBackgroundColor: var(--notificationDarkModeBackground);
  --warningBackgroundColor: var(--notificationDarkModeBackground);
  --infoBorderColor: var(--notificationDarkModeBorder);
  --successBorderColor: var(--notificationDarkModeBorder);
  --errorBorderColor: var(--notificationDarkModeBorder);
  --warningBorderColor: var(--notificationDarkModeBorder);
  --infoWarningColor: #fff;
  --successWarningColor: #fff;
  --errorWarningColor: #fff;
  --warningWarningColor: #fff;
  --infoTitleColor: #fff;
  --successTitleColor: #fff;
  --errorTitleColor: #fff;
  --warningTitleColor: #fff;
  --accordionBackgroundColor: var(--th-slate-dark);
  --accordionTextColor: #fff;
  --accordionTextBottomColor: #f5f5f5;
  --accordionIconColor: var(--toolbarWhite);
  --accordionBackgroundColorHover: var(--th-slate-dark-hover600);
  --tableBackgroundColor: var(--th-slate);
  --tableBackgroundHeaderColor: var(--th-slate-alt);
  --tableBackgroundAltColor: var(--th-slate-alt);
  --tableBackgroundHoverColor: var(--th-slate-hover);
  --tableBorderColor: var(--th-slate-dark);
  --tableTextColor: #fff;
  --ListGroupSearchItemColor: var(--th-slate-dark);
  --ListGroupSearchItemColorHover: var(--th-slate-dark-hover800);
  --ListGroupSearchItemTextColor: var(--th-white);
  --ListGroupSearchItemBorderColor:rgba(0, 0, 0, 0.225);
  --ListGroupSearchItemAsideColor: var(--th-slate-dark);
  --ListGroupSearchItemAsideTextColor: #fff;
  --inputBorder: 1px solid var(--th-slate);
  --inputTextColor: var( --th-white);
  --inputBackgroundColor: var(--th-cool-grey-800);
  --modalHeaderBackgroundColor: var(--th-cool-grey-800);
  --modalContentBackgroundColor: var(--th-cool-grey-700);
  --modalContentBorderColorHeader: var(--th-cool-grey-700);
  --modalContentBorderColorFooter: var(--th-cool-grey-700);
  --modalTextColor: var(--th-white);
  --settingsDialogBackgroundColor: var(--th-cool-grey-700);
  --settingsDialogMenuBackgroundColor: var(--th-cool-grey-800);
  --settingsDialogItemSelectedBackgroundColor: var(--th-slate-dark);
  --settingsDialogItemBackgroundColorHover: var(--th-cool-grey-700);
  --settingsDialogItemBackgroundColorActive: var(--th-cool-grey-600);
  --settingsTitleColor: #fff;
  --selectBorder: 1px solid var( --slate-light);
  --selectBackgroundColor: var( --th-slate);
  --selectBackgroundColorHover: rgba(255, 255, 255, 0.146);
  --selectBackgroundColorActive: rgba(255, 255, 255, 0.221);
  --listGroupBackgroundColor: transparent;
  --listGroupItemTextColor: var(--th-white);
  --listGroupItemBackgroundColor: var(--th-cool-grey-800);
  --listGroupItemActionsBackgroundColor: var(--th-cool-grey-850);
  --listGroupItemBackgroundColorHover: var(--th-cool-grey-700);
  --listGroupItemBackgroundColorActive: var(--th-cool-grey-600);
  --listGroupItemIconColor: var(--th-white);
  --listGroupItemArrowColor: var(--th-cool-grey-800);
}
.dark-mode.th-rw {
  --toolbarIconActiveFill: var(--white);
  --toolbarIconToggledHoverFill: var(--brandColorPurple);
  --toolbarIconToggleFill: var(--brandColorPurple);
  --toolbarIconToggleHoverFill: var(--brandColorPurple);
}
.dark-mode.th-pr {
  --toolbarButtonBackgroundHoverColor: var(--primaryColorBlue);
  --toolbarButtonBackgroundActiveColor: var(--primaryColorBlueHover);
  --toolbarButtonBorderActive: var(--buttonBorderBlueActive);
  --toolbarIconToggleFill: var(--iconToggleFillOrbitNote);
  --textColor: var(--textColorLight);
  --cardIconFillColor: var(--brandColorBlue);
  --primaryButtonBackgroundColor: var(--primaryColor);
  --primaryButtonBackgroundHoverColor: var(--primaryColorHover);
  --primaryButtonBackgroundActiveColor: var(--primaryColorActive);
  --primaryButtonBorderActive: var(--primaryButtonBorderActive);
  --primaryButtonBorder: var(--primaryButtonBorder);
  --primaryButtonBorderHover: var(--primaryButtonBorderHover);
  --dashboardTopColor: var(--primaryColorBlue);
  --dashboardTitleColor: var(--themeColorEquatio);
  --dashboardPaneBackgroundColor: var(--th-slate-dark);
  --dashboardPaneBorderColor: var(--th-slate-dark);
  --dashboardPaneDashedBorderColor: var(--dashboardDashedBorderDark);
  --listGroupItemBackgroundColor: var(--th-slate-dark);
  --listGroupItemBackgroundColorHover: var(--th-slate-dark-hover800);
  --listGroupItemBackgroundColorActive: var(--th-slate-dark-active800);
  --listGroupTileBackgroundColorActive: var(--th-slate-dark-active800);
  --list-item-hover: var(--listGroupItemBackgroundColorHover);
}
.dark-mode.th-rd {
  --toolbarIconToggledHoverFill: var(--brandColorBlue);
  --toolbarIconToggleFill: var(--brandColorBlue);
  --toolbarIconToggleHoverFill: var(--brandColorBlue);
  --dashboardTopColor: var(--th-slate);
  --dashboardCardAuditorColor: var(--primaryColorBlue);
  --dashboardCardAuditorLabelColor: var(--th-grey);
  --dashboardCardEditorColor: var(--reachDeckEditorColor);
  --dashboardCardEditorLabelColor: var(--th-grey);
  --dashboardCardToolbarColor: var(--primaryColorOrange);
  --dashboardCardToolbarLabelColor: var(--th-grey);
  --dashboardCardBorderColor: var(--th-slate-light);
  --dashboardCardFooterLinkColor: hsl(197, 100%, 50%);
  --icon-opacity: .9;
  --cardIconFillColor: var(--th-white);
  --listGroupItemBackgroundColor: var(--th-slate-dark);
  --listGroupItemBackgroundColorHover: var(--th-slate-dark-hover800);
  --listGroupItemBackgroundColorActive: var(--th-slate-dark-active800);
  --listGroupTileBackgroundColorActive: var(--th-slate-dark-active800);
  --list-item-hover: var(--listGroupItemBackgroundColorHover);
}
.dark-mode .gw-select {
  background: transparent;
  background-repeat: no-repeat, repeat;
  background-position: right 0.9em top 40%, 0 0;
  background-color: #434e65 transparent;
  border: 1px solid #fff;
  background-size: 1.3em auto, 100%;
  color: #fff;
}
.dark-mode .gw-select > option {
  background: #434e65;
}

@media (prefers-color-scheme: dark) {
  :root .day.dark-scheme {
    background: #333;
    color: white;
  }
  :root .night.dark-scheme {
    background: black;
    color: #ddd;
  }
}
@media (prefers-color-scheme: light) {
  :root .day.light-scheme {
    background: white;
    color: #555;
  }
  :root .night.light-scheme {
    background: #eee;
    color: black;
  }
}.th-rw {
  --listGroupItemBackgroundColorActive: white;
  --squareButtonBackgroundHover: #f5f5f5;
  --squareButtonIconFillColor: rgb(36, 42, 56);
  --squareButtonActiveBackGroundColor: #EFEFEF;
  --squareButtonIconTickColor: #506C7E ;
}

.dark-mode {
  --listGroupItemBackgroundColorFocus: rgb(63, 79, 90);
  --modalTextColorFocus: white;
  --listGroupItemBackgroundColorActive: rgb(36, 45, 51);
  --modalTextColorActive: white;
  --squareButtonBackgroundHover: rgb(56, 71, 81);
  --squareButtonIconFillColor: white;
  --squareButtonActiveBackGroundColor: #24323E;
  --squareButtonIconTickColor: #FFF ;
}

.dark-mode.th-rw {
  --toolbarIconButtonFillColor: var(--white);
}

.gw-toolbar--s1 {
  --fontSize: 5px;
}

.gw-toolbar--s2 {
  --fontSize: 10px;
}

.gw-toolbar--s3 {
  --fontSize: 15px;
}

.gw-toolbar--s4 {
  --fontSize: 20px;
}

.gw-listitem-fontsize-s10 {
  --gw-listitem-fontsize: 10px !important;
}

.gw-listitem-fontsize-s11 {
  --gw-listitem-fontsize: 11px !important;
}

.gw-listitem-fontsize-s12 {
  --gw-listitem-fontsize: 12px !important;
}

.gw-listitem-fontsize-s13 {
  --gw-listitem-fontsize: 13px !important;
}

.gw-listitem-fontsize-s14 {
  --gw-listitem-fontsize: 14px !important;
}

.gw-listitem-fontsize-s15 {
  --gw-listitem-fontsize: 15px !important;
}

.gw-listitem-fontsize-s16 {
  --gw-listitem-fontsize: 16px !important;
}

.gw-listitem-fontsize-s17 {
  --gw-listitem-fontsize: 17px !important;
}

.gw-listitem-fontsize-s18 {
  --gw-listitem-fontsize: 18px !important;
}

.gw-listitem-fontsize-s19 {
  --gw-listitem-fontsize: 19px !important;
}

.gw-listitem-fontsize-s20 {
  --gw-listitem-fontsize: 20px !important;
}

.gw-listitem-fontsize-s21 {
  --gw-listitem-fontsize: 21px !important;
}

.gw-listitem-fontsize-s22 {
  --gw-listitem-fontsize: 22px !important;
}

.gw-listitem-fontsize-s23 {
  --gw-listitem-fontsize: 23px !important;
}

.gw-listitem-fontsize-s24 {
  --gw-listitem-fontsize: 24px !important;
}

:root {
  --fontSize: 10px;
}

.gw-info {
  --notification-bg-color: var(--infoBackgroundColor);
  --notification-border-color: var(--infoBorderColor);
  --notification-color: var(--infoTitleColor);
}

.gw-success {
  --notification-bg-color: var(--successBackgroundColor);
  --notification-border-color: var(--successBorderColor);
  --notification-color: var(--successTitleColor);
}

.gw-error {
  --notification-bg-color: var(--errorBackgroundColor);
  --notification-border-color: var(--errorBorderColor);
  --notification-color: var(--errorTitleColor);
}

.gw-warning {
  --notification-bg-color: var(--warningBackgroundColor);
  --notification-border-color: var(--warningBorderColor);
  --notification-color: var(--warningTitleColor);
}

.th-rw {
  --toolbarIconToggleFill: var(--primaryColorPurple);
  --toolbarIconToggleHoverFill: var(--primaryColorPurple);
}

.gw-toolbar--undocked {
  --toolbarWidth: fit-content;
  --toolbarDisplay: block;
  --toolbarPosition: fixed;
}

.gw-ul--small {
  --liWidth: 150px;
}

.gw-ul--medium {
  --liWidth: 300px;
}

.gw-ul--large {
  --liWidth: 450px;
}</style><style></style></head>
<body cz-shortcut-listen="true">
  <div id="game-container">
    <div id="start-screen">
      <h1>骰子冒险 Demo</h1>
      <button id="start-btn">开始游戏</button>
      <button id="talent-btn" style="display: none;">天赋系统</button>
    </div>
    <div id="battle-screen">
      <div class="gold-display">
        <div class="gold-icon"></div>
        <span class="gold-amount">x20</span>
      </div>
      <div id="grid"></div>
      <div class="upgrade-dialog" id="upgradeDialog">
        <button class="dialog-button close-button" id="closeDialog">
          <span class="button-text">关闭</span>
        </button>
        <button class="dialog-button refresh-button" id="refreshButton">
          <span class="button-text">刷新</span>
          <div class="refresh-cost-container">
            <div class="coin-icon"></div>
            <span class="refresh-cost">10</span>
          </div>
        </button>
        <h2>升级</h2>
        <div class="upgrade-buttons">
          <!-- 按钮将通过JavaScript动态添加 -->
        </div>
      </div>

      <!-- 游戏失败提示框 -->
      <div class="game-over-dialog" id="gameOverDialog">
        <h2>游戏失败！</h2>
        <p>路飞的血量已经耗尽...</p>
        <div class="game-over-buttons">
          <button class="dialog-button restart-button" id="restartButton">
            <span class="button-text">重新开始</span>
          </button>
          <button class="dialog-button quit-button" id="quitButton">
            <span class="button-text">退出游戏</span>
          </button>
        </div>
      </div>

      <!-- 胜利弹框 -->
      <div class="victory-dialog" id="victoryDialog">
        <h2>通关胜利</h2>
      </div>

    </div>
    
    <!-- 天赋系统界面 -->
    <div class="talent-system" id="talentSystem">
      <div class="talent-header">
        <div class="talent-gold-display">
          <img src="./index_files/gold.png" alt="金币" class="talent-gold-icon">
          <span class="talent-gold-amount" id="talentGoldAmount">0</span>
        </div>
      </div>
      <div class="talent-content">
        <div class="talent-level-display" id="talentLevelDisplay">
          <span class="talent-level-text">第一关 · 沙漠之地</span>
          <div class="talent-levels-info">
            <span class="talent-level-item">生命 Lv.<span id="healthLevelDisplay">0</span></span>
            <span class="talent-level-item">护盾 Lv.<span id="shieldLevelDisplay">0</span></span>
            <span class="talent-level-item">英雄 Lv.<span id="heroLevelDisplay">0</span></span>
          </div>
        </div>
        <div class="talent-map">
          <button class="map-switch-button map-switch-left" id="mapSwitchLeft">
            <img src="./index_files/q1.png" alt="切换按钮">
          </button>
          <img src="./index_files/light1.png" alt="地图" class="talent-map-image" id="talentMapImage">
          <button class="map-switch-button map-switch-right" id="mapSwitchRight">
            <img src="./index_files/q1.png" alt="切换按钮">
          </button>
        </div>
        
        <!-- 关卡完成奖励按钮 -->
        <div class="level-reward-buttons" id="levelRewardButtons">
          <button class="level-reward-button" id="levelReward1" data-level="1">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第一关通关</span>
              <span class="reward-amount">+50金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward2" data-level="2">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第二关通关</span>
              <span class="reward-amount">+100金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward3" data-level="3">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第三关通关</span>
              <span class="reward-amount">+200金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward4" data-level="4">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第四关通关</span>
              <span class="reward-amount">+400金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward5" data-level="5">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第五关通关</span>
              <span class="reward-amount">+800金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward6" data-level="6">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第六关通关</span>
              <span class="reward-amount">+1600金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward7" data-level="7">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第七关通关</span>
              <span class="reward-amount">+3200金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward8" data-level="8">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第八关通关</span>
              <span class="reward-amount">+6400金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward9" data-level="9">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第九关通关</span>
              <span class="reward-amount">+12800金币</span>
            </div>
          </button>
          <button class="level-reward-button" id="levelReward10" data-level="10">
            <img src="./index_files/bx.png" alt="奖励" class="reward-icon">
            <div class="reward-text">
              <span class="reward-title">第十关通关</span>
              <span class="reward-amount">+25600金币</span>
            </div>
          </button>
        </div>
        
        <button class="start-game-button" id="startGameButton">开始游戏</button>
        <div class="talent-buttons">
          <button class="talent-button" id="healthTalentButton">
            <img src="./index_files/health.png" alt="生命">
            <div class="talent-button-text">
              <span>生命 Lv.<span id="healthButtonLevel">0</span></span>
              <span class="talent-effect">+20最大生命</span>
              <span class="talent-cost" id="healthTalentCost">30</span>
            </div>
            <img src="speed-button.png" alt="生命按钮" class="talent-button-icon">
          </button>
          <button class="talent-button" id="shieldTalentButton">
            <img src="./index_files/shield.png" alt="盾牌">
            <div class="talent-button-text">
              <span>护盾 Lv.<span id="shieldButtonLevel">0</span></span>
              <span class="talent-effect">+20初始护盾</span>
              <span class="talent-cost" id="shieldTalentCost">35</span>
            </div>
            <img src="rocket-button.png" alt="盾牌按钮" class="talent-button-icon">
          </button>
          <button class="talent-button" id="heroTalentButton">
            <img src="./index_files/player.png" alt="英雄">
            <div class="talent-button-text">
              <span>英雄 Lv.<span id="heroButtonLevel">0</span></span>
              <span class="talent-effect">+1英雄数量</span>
              <span class="talent-cost" id="heroTalentCost">40</span>
            </div>
            <img src="shield-button.png" alt="英雄按钮" class="talent-button-icon">
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 确保 gameConfig.js 在主脚本之前加载 -->
  <script src="./gameConfig.js"></script>
  <script>
    // 添加配置检查
    if (typeof GameConfig === 'undefined') {
      console.error('GameConfig not loaded properly!');
      alert('游戏配置加载失败，请刷新页面重试！');
    }

    // 游戏状态管理
    const GameState = {
      MENU: 'menu',
      PLAYING: 'playing',
      PAUSED: 'paused',
      GAME_OVER: 'gameOver'
    };

    // 处理响应式缩放
    function updateGameScale() {
      const gameWidth = 720;
      const gameHeight = 1280;
      
      const scaleWidth = window.innerWidth / gameWidth;
      const scaleHeight = window.innerHeight / gameHeight;
      const scale = Math.min(scaleWidth, scaleHeight, 1);
      
      document.documentElement.style.setProperty('--scale', scale);
    }

    // 创建波纹效果
    function createRippleEffect(event) {
      const button = event.currentTarget;
      const ripple = document.createElement('span');
      
      const diameter = Math.max(button.clientWidth, button.clientHeight);
      const radius = diameter / 2;
      
      ripple.style.width = ripple.style.height = `${diameter}px`;
      ripple.style.left = `${event.clientX - button.offsetLeft - radius}px`;
      ripple.style.top = `${event.clientY - button.offsetTop - radius}px`;
      ripple.className = 'ripple';
      
      button.appendChild(ripple);
      
      setTimeout(() => {
        ripple.remove();
      }, 600);
    }

    // 游戏主类
    class Game {
      constructor() {
        this.currentState = GameState.MENU;
        this.currentPlayerPosition = 0;
        this.gem1PassCount = 0;
        this.goldAmount = GameConfig.PLAYER.INITIAL_GOLD;
        this.movementPath = GameConfig.GRID_CELLS.MOVEMENT_PATH;
        this.gem2Cells = [GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM2.POSITION];
        this.gem2Levels = {}; // 英雄等级系统
        this.gem2Counters = {
          [GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM2.POSITION]: 0
        };
        
        // 天赋等级系统
        this.healthTalentLevel = 0; // 生命天赋等级
        this.shieldTalentLevel = 0; // 护盾天赋等级
        this.heroTalentLevel = 0;   // 英雄天赋等级
        
        this.talentEventsbound = false; // 标记天赋事件是否已绑定
        this.allowGem1Count = true;
        this.speedUpCount = 0;  // 新增：记录速度提升次数
        
        // 关卡奖励系统
        this.completedLevels = new Set(); // 已完成的关卡
        this.claimedRewards = new Set(); // 已领取的奖励
        this.currentLevel = 1; // 当前关卡
        
        // 地图系统
        this.currentMapId = 1; // 当前地图ID
        
        // 怪物系统相关
        this.waveNumber = 0;
        this.maxWaves = GameConfig.WAVE.MAX_WAVES;
        this.monsters = [];
        this.playerHealth = GameConfig.PLAYER.INITIAL_HEALTH;
        this.waveTimeout = null;
        this.monsterSpeed = GameConfig.MONSTER.MOVEMENT_SPEED;
        this.dangerRadius = 50;
        
        // 背景音乐系统
        this.backgroundMusic = null;
        this.musicEnabled = true;
        this.initBackgroundMusic();
        
        // 设置CSS变量
        const rocketUI = GameConfig.GRID_CELLS.SPECIAL_CELLS.ROCKET.UI;
        const styles = GameConfig.GRID_CELLS.STYLES;
        
        // 设置计数器样式
        document.documentElement.style.setProperty('--rocket-counter-font-size', `${rocketUI.COUNTER.FONT_SIZE}px`);
        document.documentElement.style.setProperty('--rocket-counter-padding', `${rocketUI.COUNTER.PADDING.Y}px ${rocketUI.COUNTER.PADDING.X}px`);
        document.documentElement.style.setProperty('--rocket-counter-radius', `${rocketUI.COUNTER.BORDER_RADIUS}px`);
        document.documentElement.style.setProperty('--rocket-counter-scale', rocketUI.COUNTER.SCALE);
        document.documentElement.style.setProperty('--rocket-counter-offset-x', `${rocketUI.COUNTER.OFFSET.X}px`);
        document.documentElement.style.setProperty('--rocket-counter-offset-y', `${rocketUI.COUNTER.OFFSET.Y}px`);
        document.documentElement.style.setProperty('--rocket-counter-bg', rocketUI.COUNTER.BACKGROUND);
        document.documentElement.style.setProperty('--rocket-counter-border', `${rocketUI.COUNTER.BORDER.WIDTH}px solid ${rocketUI.COUNTER.BORDER.COLOR}`);
        
        // 设置水位效果
        document.documentElement.style.setProperty('--water-effect-color', styles.WATER_EFFECT.COLOR);
        document.documentElement.style.setProperty('--water-effect-transition', styles.WATER_EFFECT.TRANSITION);
        document.documentElement.style.setProperty('--rocket-water-level-1', `${rocketUI.WATER_EFFECT.LEVELS.LEVEL1}%`);
        document.documentElement.style.setProperty('--rocket-water-level-2', `${rocketUI.WATER_EFFECT.LEVELS.LEVEL2}%`);
        document.documentElement.style.setProperty('--rocket-water-level-3', `${rocketUI.WATER_EFFECT.LEVELS.LEVEL3}%`);
        
        this.initialize();
      }

      initialize() {
        this.startScreen = document.getElementById('start-screen');
        this.battleScreen = document.getElementById('battle-screen');
        this.startButton = document.getElementById('start-btn');
        this.talentButton = document.getElementById('talent-btn');
        this.grid = document.getElementById('grid');
        this.goldDisplay = document.querySelector('.gold-amount');
        
        // 清理边界动画
        if (this.grid) {
          this.grid.classList.remove('grid-boundary-alert');
        }

        // 添加错误处理和默认值
        try {
          // 设置CSS变量
          const ui = GameConfig.UI || {};
          const dialog = ui.UPGRADE_DIALOG || {};
          const buttons = dialog.BUTTONS || {};
          const close = buttons.CLOSE || { WIDTH: 90, HEIGHT: 30 };
          
          document.documentElement.style.setProperty('--dialog-width', `${dialog.WIDTH || 380}px`);
          document.documentElement.style.setProperty('--dialog-top-offset', `${dialog.TOP_OFFSET || 100}px`);
          document.documentElement.style.setProperty('--dialog-padding', `${(dialog.PADDING || {}).NORMAL || 20}px`);
          document.documentElement.style.setProperty('--dialog-padding-bottom', `${(dialog.PADDING || {}).BOTTOM || 60}px`);
          document.documentElement.style.setProperty('--button-horizontal-offset', `${buttons.HORIZONTAL_OFFSET || 90}px`);
          document.documentElement.style.setProperty('--button-bottom-offset', `${buttons.BOTTOM_OFFSET || 30}px`);
          document.documentElement.style.setProperty('--health-bar-top', `${(ui.HEALTH_DISPLAY || {}).BAR_TOP || 1000}px`);
          document.documentElement.style.setProperty('--health-text-top', `${(ui.HEALTH_DISPLAY || {}).TEXT_TOP || 970}px`);
          document.documentElement.style.setProperty('--close-button-width', `${close.WIDTH}px`);
          document.documentElement.style.setProperty('--close-button-height', `${close.HEIGHT}px`);
          document.documentElement.style.setProperty('--shield-width', `${GameConfig.SKILLS.SHIELD.EFFECT.WIDTH}px`);
          document.documentElement.style.setProperty('--shield-height', `${GameConfig.SKILLS.SHIELD.EFFECT.HEIGHT}px`);
          document.documentElement.style.setProperty('--shield-color', GameConfig.SKILLS.SHIELD.EFFECT.COLOR);
        } catch (error) {
          console.error('Error setting CSS variables:', error);
        }

        this.startButton.addEventListener('click', (event) => {
          createRippleEffect(event);
          this.startGame();
        });

        this.talentButton.addEventListener('click', (event) => {
          createRippleEffect(event);
          this.showTalentSystem();
        });

        // 初始化关卡奖励按钮
        this.initializeLevelRewards();

        // 初始化响应式缩放
        window.addEventListener('resize', updateGameScale);
        updateGameScale();
        
        // 初始化主界面背景
        this.updateAllInterfaceBackgrounds();
      }

      startGame() {
        console.log('Starting game...');
        this.currentState = GameState.PLAYING;
        this.startScreen.style.display = 'none';
        this.battleScreen.style.display = 'block';
        this.updateGoldDisplay();
        
        // 设置当前地图背景
        this.updateAllInterfaceBackgrounds();
        
        // 播放背景音乐
        this.playBackgroundMusic();
        
        console.log('Initializing grid...');
        this.initializeGrid();
        console.log('Initializing game systems...');
        this.initializeGame();
        
        // 根据护盾天赋等级初始化护盾
        this.initializeTalentEffects();
        
        // 初始化波数为1并生成第一波怪物
        this.waveNumber = 1;
        this.waveText.textContent = `WAVE ${this.waveNumber}/7`;
        this.waveProgressFill.style.width = `${(this.waveNumber / this.maxWaves) * 100}%`;
        this.spawnWaveMonsters();
        
        console.log('Starting game loop...');
        this.gameLoop();
      }

      initializeGrid() {
        this.grid.innerHTML = '';
        
        const player = document.createElement('div');
        player.className = 'player';
        player.style.animation = 'playerAnimation 1.5s infinite';
        this.grid.appendChild(player);
        this.player = player;

        this.cellElements = new Array(9);

        for (let i = 0; i < 9; i++) {
          if (i === 4) continue;
          
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.style.gridArea = `cell${i + 1}`;
          cell.dataset.position = i;  // 添加位置标记
          
          if (i === GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM1.POSITION) {
            cell.classList.add('gem1');
            const waveCount = document.createElement('div');
            waveCount.className = 'wave-count';
            waveCount.textContent = 'x0';
            cell.appendChild(waveCount);
            this.gem1WaveCount = waveCount;
          }
          
          if (this.gem2Cells.includes(i)) {
            this.setupGem2Cell(cell, i);
          }
          
          this.grid.appendChild(cell);
          this.cellElements[i] = cell;
        }

        this.startPlayerMovement();
      }

      // 新增：设置gem2格子的方法
      setupGem2Cell(cell, position) {
        cell.classList.add('gem2');
        const waterContainer = document.createElement('div');
        waterContainer.className = 'water-container';
        cell.appendChild(waterContainer);
        
        const waveCount = document.createElement('div');
        waveCount.className = 'wave-count';
        waveCount.textContent = 'x0';
        cell.appendChild(waveCount);

        // 初始化这个格子的计数器
        this.gem2Counters[position] = 0;
        
        // 初始化英雄等级显示
        if (!this.gem2Levels) this.gem2Levels = {};
        if (!this.gem2Levels[position]) this.gem2Levels[position] = 1;
        this.updateGem2LevelDisplay(position);
      }

      // 新增：转换格子为gem2的方法
      convertToGem2(position) {
        const cell = this.cellElements[position];
        if (!cell) return;

        // 清除原有的内容和类
        cell.innerHTML = '';
        cell.className = 'cell';
        
        // 设置为gem2
        this.setupGem2Cell(cell, position);
        this.gem2Cells.push(position);
        
        // 初始化英雄等级
        if (!this.gem2Levels) this.gem2Levels = {};
        this.gem2Levels[position] = 1;
      }

      // 新增：升级英雄格子的方法
      upgradeGem2Cell(position) {
        const cell = this.cellElements[position];
        if (!cell || !this.gem2Cells.includes(position)) return;

        // 初始化英雄等级系统
        if (!this.gem2Levels) this.gem2Levels = {};
        if (!this.gem2Levels[position]) this.gem2Levels[position] = 1;
        
        // 升级等级
        this.gem2Levels[position]++;
        
        // 更新显示
        this.updateGem2LevelDisplay(position);
        
        // 添加升级特效
        cell.classList.add('upgrade-effect');
        setTimeout(() => {
          cell.classList.remove('upgrade-effect');
        }, 500);
      }

      // 新增：更新英雄等级显示
      updateGem2LevelDisplay(position) {
       const cell = this.cellElements[position];
       if (!cell) return;
       
       const level = this.gem2Levels[position] || 1;
       
       // 移除旧的等级显示
       let oldLevelDisplay = cell.querySelector('.gold-level');
       if (oldLevelDisplay) {
         oldLevelDisplay.remove();
       }
       
       // 创建新的等级显示，位置在右下角
       const infoDiv = document.createElement('div');
       infoDiv.className = 'gem2-level-info';
       infoDiv.innerHTML = `<div class="gold-level">Lv.${level}</div>`;
       infoDiv.style.cssText = `
         position: absolute;
         bottom: 2px;
         right: 2px;
         background: rgba(0, 0, 0, 0.7);
         color: white;
         font-size: 10px;
         padding: 2px 4px;
         border-radius: 3px;
         line-height: 1;
       `;
       
       cell.appendChild(infoDiv);
      }

      startPlayerMovement() {
        let currentIndex = this.currentIndex || 0;
        let lastCell = this.lastCell;
        let scaleTimeout = null;
        let moveInterval = 500;  // 默认移动间隔
        let isFlipped = false;  // 添加翻转状态标记

        // 初始化时添加movement类
        this.player.classList.add('player-movement');

        const movePlayer = () => {
          const targetCellIndex = this.movementPath[currentIndex];
          const targetCell = this.cellElements[targetCellIndex];
          
          if (targetCell) {
            if (lastCell) {
              lastCell.classList.remove('active');
            }
            if (scaleTimeout) {
              clearTimeout(scaleTimeout);
            }

            const rect = targetCell.getBoundingClientRect();
            const gridRect = this.grid.getBoundingClientRect();
            
            // 检查是否是8号格子，处理翻转
            if (targetCellIndex === 7) { // 索引7对应8号格子
              this.player.classList.add('flip');
            } else {
              this.player.classList.remove('flip');
            }

            // 计算居中位置：格子位置 + 格子大小的一半 - 角色大小的一半
            const cellCenterX = rect.left - gridRect.left + (rect.width / 2);
            const cellCenterY = rect.top - gridRect.top + (rect.height / 2);
            this.player.style.left = cellCenterX + 'px';
            this.player.style.top = cellCenterY + 'px';

            scaleTimeout = setTimeout(() => {
              targetCell.classList.add('active');
            }, 100);

            lastCell = targetCell;
            this.lastCell = lastCell;

            // 检查是否经过gem1
            if (targetCellIndex === GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM1.POSITION && this.allowGem1Count) {
              this.gem1PassCount++;
              this.updateWaveCount();
              
              if (this.gem1PassCount === 5) {
                if (this.moveInterval) {
                  clearInterval(this.moveInterval);
                  this.moveInterval = null;
                }
                this.showUpgradeDialog();
                return;
              }
            }
            // 检查是否经过gem2
            else if (this.gem2Cells.includes(targetCellIndex)) {
              this.gem2Counters[targetCellIndex]++;
              this.updateGem2Count(targetCellIndex);
            }
            // 检查是否经过speed格子
            else if (targetCell.dataset.isSpeedCell === 'true') {
              const speedLevel = parseInt(targetCell.dataset.speedLevel || '1');
              moveInterval = Math.max(200, 500 - (speedLevel * 100));
              if (this.moveInterval) {
                clearInterval(this.moveInterval);
                this.moveInterval = setInterval(movePlayer, moveInterval);
              }
            }
            // 检查是否经过金币格子
            else if (targetCell.dataset.isGoldCell === 'true') {
              // 增加经过次数
              const currentPassCount = parseInt(targetCell.dataset.goldPassCount || '0');
              const newPassCount = currentPassCount + 1;
              targetCell.dataset.goldPassCount = newPassCount;
              
              // 根据等级获得金币
              const goldLevel = parseInt(targetCell.dataset.goldLevel || '1');
              this.goldAmount += goldLevel;
              this.updateGoldDisplay();
              
              // 显示获得金币的文字效果
              this.showGoldGainEffect(targetCell, goldLevel);
              
              // 检查是否可以升级（每经过5次升级一次）
              if (newPassCount % 5 === 0) {
                const newLevel = goldLevel + 1;
                targetCell.dataset.goldLevel = newLevel;
                this.upgradeGoldCell(targetCell, newLevel);
              }
              
              // 更新经过次数显示
              this.updateGoldCellDisplay(targetCell, newPassCount, goldLevel);
            }

            // 检查是否有火箭
            if (targetCell.dataset.hasRocket === 'true') {
              // 增加经过次数
              const currentPassCount = parseInt(targetCell.dataset.passCount || '0');
              const newPassCount = currentPassCount + 1;
              targetCell.dataset.passCount = newPassCount;
              
              // 更新经过次数显示
              const passCountText = targetCell.querySelector('.wave-count:last-child');
              if (passCountText) {
                passCountText.textContent = `x${newPassCount}`;
              }
              
              // 检查是否达到发射条件
              if (newPassCount >= 3) {
                // 获取当前等级
                const currentLevel = parseInt(targetCell.dataset.rocketLevel || '1');
                
                // 获取多个不同的怪物目标
                const availableMonsters = [...this.monsters];
                const targets = [];
                
                // 根据火箭等级选择不同的怪物目标
                for (let i = 0; i < currentLevel && i < availableMonsters.length; i++) {
                  // 找到距离发射点最近的未被选中的怪物
                  const cellRect = targetCell.getBoundingClientRect();
                  const startX = cellRect.left + cellRect.width / 2;
                  const startY = cellRect.top + cellRect.height / 2;
                  
                  let nearestMonster = null;
                  let minDistance = Infinity;
                  
                  availableMonsters.forEach(monster => {
                    const dx = monster.x - startX;
                    const dy = monster.y - startY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                      minDistance = distance;
                      nearestMonster = monster;
                    }
                  });
                  
                  if (nearestMonster) {
                    targets.push(nearestMonster);
                    // 从可用列表中移除，确保下一个火箭选择不同目标
                    const index = availableMonsters.indexOf(nearestMonster);
                    if (index > -1) {
                      availableMonsters.splice(index, 1);
                    }
                  }
                }
                
                // 发射对应数量的火箭到不同目标
                let delay = 0;
                targets.forEach((target, index) => {
                  setTimeout(() => {
                    this.fireRocket(targetCell, target);
                  }, delay);
                  delay += GameConfig.GRID_CELLS.SPECIAL_CELLS.ROCKET.STACK.LAUNCH_DELAY;
                });
                
                // 添加发射动画
                const rocketImg = targetCell.querySelector('.cell-image');
                if (rocketImg) {
                  rocketImg.style.animation = 'rocketLaunch 0.3s ease';
                  setTimeout(() => {
                    rocketImg.style.animation = '';
                  }, 300);
                }
                
                // 重置经过次数
                targetCell.dataset.passCount = '0';
                if (passCountText) {
                  passCountText.textContent = 'x0';
                }
              }

              // 添加水波纹效果
              const waterContainer = targetCell.querySelector('.water-container');
              if (waterContainer) {
                waterContainer.classList.remove('ripple');
                void waterContainer.offsetWidth;
                waterContainer.classList.add('ripple');
                setTimeout(() => {
                  waterContainer.classList.remove('ripple');
                }, 500);
              }
            }
          }
          
          this.currentIndex = currentIndex;
          currentIndex = (currentIndex + 1) % this.movementPath.length;
        };

        // 如果已经有一个活动的格子，先移除其active状态
        const activeCell = document.querySelector('.cell.active');
        if (activeCell) {
          activeCell.classList.remove('active');
        }

        // 立即移动到当前位置
        movePlayer();
        
        // 如果已经有一个移动间隔，先清除它
        if (this.moveInterval) {
          clearInterval(this.moveInterval);
        }
        this.moveInterval = setInterval(movePlayer, moveInterval);
      }

      initializeGame() {
        // 确保玩家生命值考虑天赋加成
        const maxHealth = GameConfig.PLAYER.INITIAL_HEALTH + 20 * this.healthTalentLevel;
        // 如果玩家生命值未初始化或小于最大生命值，则设置为最大生命值
        if (!this.playerHealth || this.playerHealth < maxHealth) {
          this.playerHealth = maxHealth;
        }
        
        // 添加血量文字显示
        const healthText = document.createElement('div');
        healthText.className = 'health-text';
        healthText.textContent = `路飞血量：${this.playerHealth}/${maxHealth}`;
        this.battleScreen.appendChild(healthText);
        this.healthText = healthText;

        // 添加血条
        const healthBar = document.createElement('div');
        healthBar.className = 'health-bar';
        const healthFill = document.createElement('div');
        healthFill.className = 'health-fill';
        // 设置初始血条宽度
        const healthPercentage = (this.playerHealth / maxHealth) * 100;
        healthFill.style.width = `${healthPercentage}%`;
        healthBar.appendChild(healthFill);
        this.battleScreen.appendChild(healthBar);
        this.healthFill = healthFill;

        // 添加波数显示
        const waveIndicator = document.createElement('div');
        waveIndicator.className = 'wave-indicator';
        
        // 添加关卡名称显示
        const levelNameText = document.createElement('div');
        levelNameText.className = 'level-name-text';
        const currentMap = GameConfig.MAPS[this.currentMapId];
        levelNameText.textContent = currentMap ? currentMap.NAME : '第一关 · 沙漠之地';
        waveIndicator.appendChild(levelNameText);
        
        const waveText = document.createElement('span');
        waveText.textContent = 'WAVE 0/7';
        waveIndicator.appendChild(waveText);
        
        const waveProgress = document.createElement('div');
        waveProgress.className = 'wave-progress';
        const waveProgressFill = document.createElement('div');
        waveProgressFill.className = 'wave-progress-fill';
        waveProgress.appendChild(waveProgressFill);
        waveIndicator.appendChild(waveProgress);
        
        this.battleScreen.appendChild(waveIndicator);
        this.waveText = waveText;
        this.waveProgressFill = waveProgressFill;
        this.levelNameText = levelNameText;
      }

      spawnWaveMonsters() {
        console.log(`Spawning monsters for wave ${this.waveNumber}`);
        
        // 根据英雄天赋等级增加怪物数量：每级增加怪物数量上限 +1
        const baseMonsterCount = this.waveNumber;
        const talentMonsterBonus = this.heroTalentLevel; // 每级增加1个怪物
        const totalMonsterCount = baseMonsterCount + talentMonsterBonus;
        
        // 生成怪物
        for (let i = 0; i < totalMonsterCount; i++) {
          this.spawnMonster(false);  // 生成普通怪物
        }

        // 在第三波额外生成一个BOSS
        if (this.waveNumber === GameConfig.MONSTER.BOSS.WAVE) {
          this.spawnMonster(true);  // 生成BOSS
        }
      }

      spawnMonster(isBoss = false) {
        const angle = Math.random() * Math.PI * 2;
        const distance = GameConfig.MONSTER.SPAWN_DISTANCE;
        
        const gridRect = this.grid.getBoundingClientRect();
        const centerX = gridRect.left + gridRect.width / 2;
        const centerY = gridRect.top + gridRect.height / 2;
        
        const monsterSize = isBoss ? GameConfig.MONSTER.BOSS.SIZE : GameConfig.MONSTER.SIZE;
        const monsterX = centerX + Math.cos(angle) * distance - monsterSize.WIDTH / 2;
        const monsterY = centerY + Math.sin(angle) * distance - monsterSize.HEIGHT / 2;

        // 应用动态平衡公式
        const waveMultiplier = isBoss ? GameConfig.BALANCE.WAVE_SCALING.BOSS_MULTIPLIER : 1;
        const healthScaling = 1 + (this.waveNumber - 1) * GameConfig.BALANCE.WAVE_SCALING.MONSTER_HEALTH;
        const damageScaling = 1 + (this.waveNumber - 1) * GameConfig.BALANCE.WAVE_SCALING.MONSTER_DAMAGE;
        const goldScaling = 1 + (this.waveNumber - 1) * GameConfig.BALANCE.WAVE_SCALING.GOLD_REWARD;
        
        // 应用天赋增强公式（下一关的敌人增强）
        const talentHealthMultiplier = 1 + this.healthTalentLevel * 0.1; // 每级使怪物HP +10%
        const talentDamageMultiplier = 1 + this.shieldTalentLevel * 0.1; // 每级使怪物攻击力 +10%

        const monster = document.createElement('div');
        monster.className = 'monster';
        
        if (isBoss) {
          monster.classList.add('boss');
          monster.style.animation = `bossAnimation ${GameConfig.MONSTER.BOSS.ANIMATION_INTERVAL}ms infinite`;
        } else {
          // 根据当前地图配置设置普通怪物图片
          const currentMap = GameConfig.MAPS[this.currentMapId];
          if (currentMap && currentMap.MONSTER_IMAGES && currentMap.MONSTER_IMAGES.length > 0) {
            const randomMonsterImage = currentMap.MONSTER_IMAGES[Math.floor(Math.random() * currentMap.MONSTER_IMAGES.length)];
            monster.style.backgroundImage = `url('./index_files/${randomMonsterImage}')`;
          }
        }
        
        // 添加血条
        const healthBar = document.createElement('div');
        healthBar.className = 'monster-health';
        const healthFill = document.createElement('div');
        healthFill.className = 'monster-health-fill';
        healthBar.appendChild(healthFill);
        monster.appendChild(healthBar);
        
        document.body.appendChild(monster);
        
        monster.style.left = `${monsterX}px`;
        monster.style.top = `${monsterY}px`;

        // 计算动态血量
        const baseHealth = isBoss ? GameConfig.MONSTER.BOSS.HEALTH : GameConfig.MONSTER.INITIAL_HEALTH;
        const scaledHealth = Math.floor(baseHealth * healthScaling * waveMultiplier * talentHealthMultiplier);
        
        const monsterObj = {
          element: monster,
          healthElement: healthFill,
          x: monsterX + monsterSize.WIDTH / 2,
          y: monsterY + monsterSize.HEIGHT / 2,
          health: scaledHealth,
          isBoss: isBoss,
          maxHealth: scaledHealth,
          damage: Math.floor((isBoss ? GameConfig.MONSTER.BOSS.DAMAGE : GameConfig.MONSTER.DAMAGE) * damageScaling * waveMultiplier * talentDamageMultiplier),
          goldReward: Math.floor((isBoss ? GameConfig.MONSTER.BOSS.GOLD_REWARD : GameConfig.MONSTER.GOLD_REWARD) * goldScaling * waveMultiplier)
        };

        this.monsters.push(monsterObj);
      }

      updateMonsters() {
        const gridRect = this.grid.getBoundingClientRect();
        const gridLeft = gridRect.left;
        const gridRight = gridRect.right;
        const gridTop = gridRect.top;
        const gridBottom = gridRect.bottom;
        const centerX = gridLeft + gridRect.width / 2;
        const gridCenterY = gridTop + gridRect.height / 2;

        this.monsters.forEach((monster, index) => {
          const monsterRect = monster.element.getBoundingClientRect();
          
          // 检查是否碰到格子边界
          if (monsterRect.right >= gridLeft && 
              monsterRect.left <= gridRight && 
              monsterRect.bottom >= gridTop && 
              monsterRect.top <= gridBottom) {
            // 怪物碰到边界时只扣血，不消失
            if (!monster.isAtBoundary) {
              monster.isAtBoundary = true;
              // 添加边界红色呼吸动画
              this.grid.classList.add('grid-boundary-alert');
              monster.boundaryDamageTimer = setInterval(() => {
                this.playerTakeDamage(monster.damage || GameConfig.MONSTER.DAMAGE_TO_PLAYER);
              }, 1000); // 每秒扣血一次
            }
            return;
          } else {
            // 怪物离开边界时停止扣血
            if (monster.isAtBoundary) {
              monster.isAtBoundary = false;
              if (monster.boundaryDamageTimer) {
                clearInterval(monster.boundaryDamageTimer);
                monster.boundaryDamageTimer = null;
              }
              // 检查是否还有其他怪物在边界，如果没有则移除动画
              const hasMonsterAtBoundary = this.monsters.some(m => m.isAtBoundary && m !== monster);
              if (!hasMonsterAtBoundary) {
                this.grid.classList.remove('grid-boundary-alert');
              }
            }
          }

          // 其他移动逻辑保持不变
          const monsterCenterX = monsterRect.left + GameConfig.MONSTER.SIZE.WIDTH / 2;
          const monsterCenterY = monsterRect.top + GameConfig.MONSTER.SIZE.HEIGHT / 2;
          
          const dx = centerX - monsterCenterX;
          const dy = gridCenterY - monsterCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 0) {
            const moveX = (dx / distance) * this.monsterSpeed;
            const moveY = (dy / distance) * this.monsterSpeed;
            
            const newX = monsterCenterX + moveX - GameConfig.MONSTER.SIZE.WIDTH / 2;
            const newY = monsterCenterY + moveY - GameConfig.MONSTER.SIZE.HEIGHT / 2;
            monster.element.style.left = `${newX}px`;
            monster.element.style.top = `${newY}px`;
            
            monster.x = newX + GameConfig.MONSTER.SIZE.WIDTH / 2;
            monster.y = newY + GameConfig.MONSTER.SIZE.HEIGHT / 2;
          }
        });
      }

      playerTakeDamage(damage, fromBoss = false) {
        const grid = document.getElementById('grid');
        let actualDamage = fromBoss ? GameConfig.MONSTER.BOSS.DAMAGE : damage;
        
        // 检查是否有盾牌效果
        if (grid && grid.dataset.shieldHealth) {
          const shieldHealth = parseInt(grid.dataset.shieldHealth);
          if (shieldHealth > 0) {
            // 计算盾牌能吸收的伤害
            const absorbedDamage = Math.min(shieldHealth, actualDamage);
            actualDamage -= absorbedDamage;
            
            // 更新盾牌血量
            const remainingShieldHealth = shieldHealth - absorbedDamage;
            grid.dataset.shieldHealth = remainingShieldHealth.toString();
            
            // 更新盾牌血量显示
            const shieldHealthDisplay = grid.querySelector('.shield-health');
            if (shieldHealthDisplay) {
              shieldHealthDisplay.textContent = remainingShieldHealth.toString();
            }
            
            // 如果盾牌耗尽，移除盾牌效果
            if (remainingShieldHealth <= 0) {
              const shieldContainer = grid.querySelector('.shield-container');
              if (shieldContainer) {
                shieldContainer.remove();
              }
              delete grid.dataset.shieldHealth;
            }
          }
        }

        // 处理剩余伤害
        if (actualDamage > 0) {
          this.playerHealth = Math.max(0, this.playerHealth - actualDamage);
          const maxHealth = GameConfig.PLAYER.INITIAL_HEALTH + 20 * this.healthTalentLevel;
          const healthPercentage = (this.playerHealth / maxHealth) * 100;
          this.healthFill.style.width = `${healthPercentage}%`;
          this.healthText.textContent = `路飞血量：${this.playerHealth}/${maxHealth}`;

          // 显示飘血效果
          const damageText = document.createElement('div');
          damageText.className = 'damage-text';
          damageText.textContent = `-${actualDamage}`;
          damageText.style.left = '50%';
          damageText.style.top = '50%';
          this.battleScreen.appendChild(damageText);

          // 移除飘血效果
          setTimeout(() => {
            damageText.remove();
          }, 1000);

          // 检查游戏结束
          if (this.playerHealth <= 0) {
            this.gameOver();
          }
        }
      }

      removeMonster(index) {
        // 添加安全检查
        if (index < 0 || index >= this.monsters.length) {
          console.warn('Invalid monster index:', index);
          return;
        }

        const monster = this.monsters[index];
        // 添加安全检查
        if (!monster) {
          console.warn('Monster not found at index:', index);
          return;
        }

        try {
          // 清理边界伤害定时器
          if (monster.boundaryDamageTimer) {
            clearInterval(monster.boundaryDamageTimer);
            monster.boundaryDamageTimer = null;
          }
          
          // 如果被消灭的怪物在边界，检查是否需要移除边界动画
          if (monster.isAtBoundary) {
            // 检查是否还有其他怪物在边界
            const hasOtherMonsterAtBoundary = this.monsters.some((m, i) => i !== index && m.isAtBoundary);
            if (!hasOtherMonsterAtBoundary) {
              this.grid.classList.remove('grid-boundary-alert');
            }
          }
          
          if (monster.element && monster.element.parentNode) {
            const monsterRect = monster.element.getBoundingClientRect();
            const monsterX = monsterRect.left + monsterRect.width / 2;
            const monsterY = monsterRect.top + monsterRect.height / 2;
            
            // 使用动态金币奖励
            const goldReward = monster.goldReward || (monster.isBoss ? GameConfig.MONSTER.BOSS.GOLD_REWARD : GameConfig.MONSTER.KILL_GOLD_REWARD);
            this.spawnCoins(monsterX, monsterY, goldReward);
            
            monster.element.parentNode.removeChild(monster.element);
          }
          this.monsters.splice(index, 1);

          if (this.monsters.length === 0 && this.gem1PassCount < GameConfig.SKILLS.GEM1.MAX_COUNT) {
            // 检查是否完成第7波
            if (this.waveNumber >= this.maxWaves) {
              this.showVictoryDialog();
            } else {
              this.spawnWaveMonsters();
            }
          }
        } catch (error) {
          console.error('Error removing monster:', error);
          // 确保即使出错也能移除怪物
          this.monsters.splice(index, 1);
        }
      }

      spawnCoins(x, y, count) {
        const goldDisplay = document.querySelector('.gold-display');
        const goldRect = goldDisplay.getBoundingClientRect();
        const targetX = goldRect.left + goldRect.width / 2;
        const targetY = goldRect.top + goldRect.height / 2;

        for (let i = 0; i < count; i++) {
          const coin = document.createElement('div');
          coin.className = 'coin';
          document.body.appendChild(coin);

          // 设置初始位置
          coin.style.left = `${x}px`;
          coin.style.top = `${y}px`;

          // 添加初始浮动动画
          coin.style.animation = 'coinFloat 0.5s ease-out';

          // 延迟一点开始飞向目标
          setTimeout(() => {
            // 移除浮动动画
            coin.style.animation = 'none';
            
            // 开始飞向金币框
            coin.style.left = `${targetX}px`;
            coin.style.top = `${targetY}px`;
            coin.style.transform = 'scale(0.5)';
            coin.style.opacity = '0';

            // 到达后移除coin元素并更新金币数
            setTimeout(() => {
              coin.remove();
              this.goldAmount += 1;
              this.updateGoldDisplay();
            }, 500);
          }, i * 100 + 500); // 每个金币延迟不同时间开始移动
        }
      }

      updateGoldDisplay() {
        const goldDisplay = document.querySelector('.gold-amount');
        
        // 添加数字变化动画
        goldDisplay.style.transform = 'scale(1.2)';
        goldDisplay.textContent = `x${this.goldAmount}`;
        
        setTimeout(() => {
          goldDisplay.style.transform = 'scale(1)';
        }, 200);
        
        // 更新升级按钮的金币颜色
        this.updateUpgradeButtonColors();
      }
      
      // 更新升级按钮的金币颜色
      updateUpgradeButtonColors() {
        const upgradeDialog = document.getElementById('upgradeDialog');
        if (upgradeDialog && upgradeDialog.style.display === 'block') {
          const costAmounts = upgradeDialog.querySelectorAll('.cost-amount');
          const upgradeButtons = upgradeDialog.querySelectorAll('.upgrade-button');
          
          upgradeButtons.forEach((button, index) => {
            const costAmount = costAmounts[index];
            if (costAmount && this.currentUpgradeButtons && this.currentUpgradeButtons[index]) {
              // 使用动态成本计算
              const buttonConfig = this.currentUpgradeButtons[index];
              const upgradeCount = this.upgradeCount[buttonConfig.ID] || 0;
              const dynamicCost = Math.floor(buttonConfig.COST * Math.pow(GameConfig.BALANCE.COST_SCALING.UPGRADE_BASE, upgradeCount));
              
              if (this.goldAmount < dynamicCost) {
                costAmount.classList.add('insufficient');
              } else {
                costAmount.classList.remove('insufficient');
              }
            }
          });
        }
      }

      gameOver() {
        this.currentState = GameState.GAME_OVER;
        // 清除所有怪物
        this.clearCurrentWave();
        // 停止玩家移动
        clearInterval(this.moveInterval);
        
        // 显示自定义游戏失败对话框
        this.showGameOverDialog();
      }

      showGameOverDialog() {
        const dialog = document.getElementById('gameOverDialog');
        const restartButton = document.getElementById('restartButton');
        const quitButton = document.getElementById('quitButton');
        
        // 显示对话框
        dialog.style.display = 'block';
        
        // 绑定重新开始按钮事件
        restartButton.onclick = () => {
          dialog.style.display = 'none';
          this.resetGame();
        };
        
        // 绑定退出游戏按钮事件
        quitButton.onclick = () => {
          dialog.style.display = 'none';
          this.resetGame();  // 退出游戏时也要清理所有定时器和状态
          document.getElementById('battle-screen').style.display = 'none';
          document.getElementById('start-screen').style.display = 'flex';
        };
      }

      resetGame() {
        // 重置所有游戏状态
        this.currentState = GameState.MENU;
        this.currentPlayerPosition = 0;
        this.currentIndex = 0;  // 重置角色位置索引
        this.gem1PassCount = 0;
        this.goldAmount = GameConfig.PLAYER.INITIAL_GOLD;
        this.allowGem1Count = true;
        this.speedUpCount = 0;
        
        // 关卡进度逻辑：如果刚刚完成了一关，进入下一关
        if (this.currentState === GameState.PLAYING) {
          // 只有在游戏进行中重置才增加关卡（表示完成了当前关卡）
          this.currentLevel++;
        }
        
        // 清理所有speed格子
        this.cellElements.forEach(cell => {
          if (cell && cell.classList.contains('speed')) {
            cell.classList.remove('speed');
            cell.removeAttribute('data-is-speed-cell');
        cell.removeAttribute('data-speed-level');
         const speedInfo = cell.querySelector('.speed-level-info');
         if (speedInfo) {
           speedInfo.remove();
         }
          }
          
          // 清理所有金币格子
          if (cell && cell.classList.contains('gold-cell')) {
            cell.classList.remove('gold-cell');
            cell.style.backgroundImage = '';
            cell.removeAttribute('data-is-gold-cell');
          }
          
          // 清理所有rocket格子
          if (cell && cell.dataset.hasRocket === 'true') {
            cell.removeAttribute('data-has-rocket');
            cell.removeAttribute('data-rocket-level');
            cell.removeAttribute('data-pass-count');
            const rocketImg = cell.querySelector('.cell-image');
            if (rocketImg) {
              rocketImg.remove();
            }
            const waterEffect = cell.querySelector('.water-effect');
            if (waterEffect) {
              waterEffect.remove();
            }
            const rocketLevelInfo = cell.querySelector('.rocket-level-info');
            if (rocketLevelInfo) {
              rocketLevelInfo.remove();
            }
            const waveCount = cell.querySelector('.wave-count');
            if (waveCount) {
              waveCount.remove();
            }
          }
        });
        
        // 重置怪物系统
        this.waveNumber = 0;
        // 清理所有怪物的边界伤害定时器和DOM元素
        this.monsters.forEach(monster => {
          if (monster.boundaryDamageTimer) {
            clearInterval(monster.boundaryDamageTimer);
            monster.boundaryDamageTimer = null;
          }
          // 重置边界状态
          monster.isAtBoundary = false;
          // 移除怪物DOM元素
          if (monster.element && monster.element.parentNode) {
            monster.element.parentNode.removeChild(monster.element);
          }
        });
        
        // 清理所有可能残留的怪物DOM元素
        const remainingMonsters = document.querySelectorAll('.monster');
        remainingMonsters.forEach(monster => {
          if (monster.parentNode) {
            monster.parentNode.removeChild(monster);
          }
        });
        
        this.monsters = [];
        // 清理边界动画
        this.grid.classList.remove('grid-boundary-alert');
        // 设置玩家生命值，考虑天赋加成
        this.playerHealth = GameConfig.PLAYER.INITIAL_HEALTH + 20 * this.healthTalentLevel;
        this.waveTimeout = null;
        this.monsterSpeed = GameConfig.MONSTER.MOVEMENT_SPEED;
        
        // 重置gem2计数器
        this.gem2Counters = {
          [GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM2.POSITION]: 0
        };
        
        // 重置gem2Cells数组，只保留默认的英雄格子
        this.gem2Cells = [GameConfig.GRID_CELLS.SPECIAL_CELLS.GEM2.POSITION];
        
        // 清除所有定时器
        if (this.waveTimeout) {
          clearTimeout(this.waveTimeout);
          this.waveTimeout = null;
        }
        if (this.moveInterval) {
          clearInterval(this.moveInterval);
          this.moveInterval = null;
        }
        
        // 清理所有可能的全局定时器（防止遗漏）
        for (let i = 1; i < 10000; i++) {
          clearTimeout(i);
          clearInterval(i);
        }
        
        // 隐藏升级对话框
        const upgradeDialog = document.getElementById('upgradeDialog');
        if (upgradeDialog) {
          upgradeDialog.style.display = 'none';
        }
        
        // 清理所有动态创建的UI元素
        const existingHealthText = this.battleScreen.querySelector('.health-text');
        if (existingHealthText) {
          existingHealthText.remove();
        }
        const existingHealthBar = this.battleScreen.querySelector('.health-bar');
        if (existingHealthBar) {
          existingHealthBar.remove();
        }
        const existingWaveIndicator = this.battleScreen.querySelector('.wave-indicator');
        if (existingWaveIndicator) {
          existingWaveIndicator.remove();
        }
        
        // 清理所有伤害文字
        const damageTexts = this.battleScreen.querySelectorAll('.damage-text');
        damageTexts.forEach(text => text.remove());
        
        // 重置UI引用
        this.healthText = null;
        this.healthFill = null;
        this.waveText = null;
        this.waveProgressFill = null;
        
        // 更新金币显示
        this.updateGoldDisplay();
        
        // 重新开始游戏 - 和开始游戏按钮功能一致
        console.log('Restarting game...');
        this.currentState = GameState.PLAYING;
        this.startScreen.style.display = 'none';
        this.battleScreen.style.display = 'block';
        
        console.log('Reinitializing grid...');
        this.initializeGrid();
        console.log('Reinitializing game systems...');
        this.initializeGame();
        
        // 初始化波数为1并生成第一波怪物
        this.waveNumber = 1;
        this.waveText.textContent = `WAVE ${this.waveNumber}/7`;
        this.waveProgressFill.style.width = `${(this.waveNumber / this.maxWaves) * 100}%`;
        this.spawnWaveMonsters();
        
        console.log('Restarting game loop...');
        this.gameLoop();
      }

      // 显示胜利弹框
      showVictoryDialog() {
        const victoryDialog = document.getElementById('victoryDialog');
        victoryDialog.style.display = 'block';
        
        // 完成当前关卡
        this.completeLevel(this.currentMapId);
        
        // 2秒后关闭胜利对话框，切换到下一关卡并打开天赋系统
        setTimeout(() => {
          victoryDialog.style.display = 'none';
          
          // 自动切换到下一关卡
          this.autoSwitchToNextMap();
          
          // 打开天赋系统
          this.showTalentSystem();
        }, 2000);
      }
      
      // 自动切换到下一关卡
      autoSwitchToNextMap() {
        const maps = GameConfig.MAPS;
        const mapIds = Object.keys(maps).map(id => parseInt(id)).sort((a, b) => a - b);
        const currentIndex = mapIds.indexOf(this.currentMapId);
        
        // 如果不是最后一关，切换到下一关
        if (currentIndex < mapIds.length - 1) {
          this.currentMapId = mapIds[currentIndex + 1];
          
          // 更新所有界面的背景
          this.updateAllInterfaceBackgrounds();
        }
      }
      
      // 更新所有界面的背景
      updateAllInterfaceBackgrounds() {
        const currentMap = GameConfig.MAPS[this.currentMapId];
        const gameContainer = document.getElementById('game-container');
        
        if (gameContainer && currentMap) {
          // 优先使用BATTLE_BACKGROUND，如果没有则使用BACKGROUND
          const backgroundImage = currentMap.BATTLE_BACKGROUND || `./index_files/${currentMap.BACKGROUND}.png`;
          gameContainer.style.backgroundImage = `url('${backgroundImage}')`;
          
          // 更新战斗界面中的关卡名称显示
          if (this.levelNameText) {
            this.levelNameText.textContent = currentMap.NAME;
          }
          
          // 更新天赋系统中的关卡名称显示
          const levelDisplay = document.getElementById('talentLevelDisplay');
          if (levelDisplay) {
            const levelTextElement = levelDisplay.querySelector('.talent-level-text');
            if (levelTextElement) {
              levelTextElement.textContent = currentMap.NAME;
            }
          }
          
          // 更新奖励按钮状态
          this.updateRewardButtonStates();
        }
      }

      // 重置到主界面
      resetToMainScreen() {
        this.currentState = GameState.MENU;
        this.battleScreen.style.display = 'none';
        this.startScreen.style.display = 'block';
      }

      // 初始化关卡奖励按钮
      initializeLevelRewards() {
        const rewardButtons = document.querySelectorAll('.level-reward-button');
        rewardButtons.forEach(button => {
          button.addEventListener('click', (event) => {
            const level = parseInt(button.dataset.level);
            this.claimLevelReward(level);
          });
        });
        
        // 更新奖励按钮状态
        this.updateRewardButtonStates();
      }

      // 更新奖励按钮状态
      updateRewardButtonStates() {
        const rewardButtons = document.querySelectorAll('.level-reward-button');
        
        // 计算要显示的关卡范围（当前关卡及前后各1关，最多3个）
        const currentLevel = this.currentMapId;
        const startLevel = Math.max(1, currentLevel - 1);
        const endLevel = Math.min(10, startLevel + 2);
        
        rewardButtons.forEach(button => {
          const level = parseInt(button.dataset.level);
          
          // 移除所有状态类
          button.classList.remove('available', 'claimed');
          
          // 判断是否应该显示这个按钮
          if (level >= startLevel && level <= endLevel) {
            button.style.display = 'flex';
            
            if (this.claimedRewards.has(level)) {
              // 已领取
              button.classList.add('claimed');
            } else if (this.completedLevels.has(level)) {
              // 可领取
              button.classList.add('available');
            }
            // 默认状态（不可领取）不需要添加类
          } else {
            // 隐藏不在显示范围内的按钮
            button.style.display = 'none';
          }
        });
      }

      // 领取关卡奖励
      claimLevelReward(level) {
        // 检查是否已完成关卡且未领取奖励
        if (!this.completedLevels.has(level) || this.claimedRewards.has(level)) {
          return;
        }
        
        // 计算奖励金币（公式：基础奖励 * 关卡系数）
        const baseReward = 50;
        const rewardAmount = baseReward * Math.pow(2, level - 1); // 50, 100, 200, 400...
        
        // 添加金币
        this.goldAmount += rewardAmount;
        this.updateGoldDisplay();
        
        // 标记为已领取
        this.claimedRewards.add(level);
        
        // 更新按钮状态
        this.updateRewardButtonStates();
        
        // 显示奖励提示
        this.showRewardNotification(rewardAmount);
      }

      // 显示奖励通知
      showRewardNotification(amount) {
        // 创建通知元素
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #ffd700, #ffb347);
          color: #333;
          padding: 15px 25px;
          border-radius: 10px;
          font-size: 18px;
          font-weight: bold;
          z-index: 10005;
          box-shadow: 0 4px 20px rgba(255, 215, 0, 0.5);
          animation: rewardPop 2s ease-out forwards;
        `;
        notification.textContent = `+${amount} 金币！`;
        
        // 添加动画样式
        if (!document.getElementById('rewardAnimationStyle')) {
          const style = document.createElement('style');
          style.id = 'rewardAnimationStyle';
          style.textContent = `
            @keyframes rewardPop {
              0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
              20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
              100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
            }
          `;
          document.head.appendChild(style);
        }
        
        document.body.appendChild(notification);
        
        // 2秒后移除通知
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 2000);
      }

      // 完成关卡（在游戏胜利时调用）
      completeLevel(level) {
        this.completedLevels.add(level);
        this.updateRewardButtonStates();
      }

      // 显示天赋系统
      showTalentSystem() {
        console.log('showTalentSystem called');
        const talentSystem = document.getElementById('talentSystem');
        const talentGoldAmount = document.getElementById('talentGoldAmount');
        
        console.log('talentSystem element:', talentSystem);
        console.log('talentGoldAmount element:', talentGoldAmount);
        
        if (!talentSystem) {
          console.error('talentSystem element not found!');
          return;
        }
        
        if (!talentGoldAmount) {
          console.error('talentGoldAmount element not found!');
          return;
        }
        
        // 更新金币显示
        talentGoldAmount.textContent = this.goldAmount;
        
        // 更新天赋等级显示
        this.updateTalentLevelDisplays();
        
        // 更新关卡奖励按钮状态
        this.updateRewardButtonStates();
        
        // 随机生成天赋按钮成本
        this.generateTalentCosts();
        
        // 显示天赋系统
        console.log('Setting talentSystem display to flex');
        talentSystem.style.display = 'flex';
        console.log('talentSystem display after setting:', talentSystem.style.display);
        
        // 绑定按钮事件
        this.bindTalentEvents();
      }

      // 生成随机天赋成本
      generateTalentCosts() {
        const healthCost = Math.floor(Math.random() * 11) + 30; // 30-40
        const shieldCost = Math.floor(Math.random() * 11) + 30; // 30-40
        const heroCost = Math.floor(Math.random() * 11) + 30; // 30-40
        
        document.getElementById('healthTalentCost').textContent = healthCost;
        document.getElementById('shieldTalentCost').textContent = shieldCost;
        document.getElementById('heroTalentCost').textContent = heroCost;
        
        // 更新按钮状态
        this.updateTalentButtonStates();
      }

      // 更新天赋按钮状态
      updateTalentButtonStates() {
        const buttons = [
          { button: document.getElementById('healthTalentButton'), cost: parseInt(document.getElementById('healthTalentCost').textContent) },
          { button: document.getElementById('shieldTalentButton'), cost: parseInt(document.getElementById('shieldTalentCost').textContent) },
          { button: document.getElementById('heroTalentButton'), cost: parseInt(document.getElementById('heroTalentCost').textContent) }
        ];
        
        buttons.forEach(({ button, cost }) => {
          if (this.goldAmount < cost) {
            button.classList.add('insufficient');
          } else {
            button.classList.remove('insufficient');
          }
        });
      }

      // 绑定天赋系统事件
      bindTalentEvents() {
        const startGameButton = document.getElementById('startGameButton');
        const healthTalentButton = document.getElementById('healthTalentButton');
        const shieldTalentButton = document.getElementById('shieldTalentButton');
        const heroTalentButton = document.getElementById('heroTalentButton');
        const mapSwitchLeft = document.getElementById('mapSwitchLeft');
        const mapSwitchRight = document.getElementById('mapSwitchRight');
        const talentMapImage = document.getElementById('talentMapImage');
        
        // 移除之前的事件监听器，避免重复绑定
        if (this.talentEventsbound) {
          return; // 如果已经绑定过事件，直接返回
        }
        
        // 开始游戏按钮
        startGameButton.addEventListener('click', (event) => {
          createRippleEffect(event);
          const talentSystem = document.getElementById('talentSystem');
          talentSystem.style.display = 'none';
          this.resetGame();
          this.startGame(); // 直接调用startGame方法进入战斗界面
        });
        
        // 地图切换按钮
        const levelDisplay = document.getElementById('talentLevelDisplay');
        const levelTextElement = levelDisplay.querySelector('.talent-level-text');
        const maps = GameConfig.MAPS;
        const mapIds = Object.keys(maps).map(id => parseInt(id));
        
        // 更新地图显示函数
        const updateMapDisplay = () => {
          const currentMap = maps[this.currentMapId];
          levelTextElement.textContent = currentMap.NAME;
          talentMapImage.src = `./index_files/${currentMap.BACKGROUND}.png`;
          
          // 调用统一的背景更新方法
          this.updateAllInterfaceBackgrounds();
          
          // 更新奖励按钮状态
          this.updateRewardButtonStates();
        };
        
        // 初始化显示当前地图
        updateMapDisplay();
        
        mapSwitchLeft.addEventListener('click', (event) => {
          createRippleEffect(event);
          const currentIndex = mapIds.indexOf(this.currentMapId);
          const newIndex = (currentIndex - 1 + mapIds.length) % mapIds.length;
          this.currentMapId = mapIds[newIndex];
          updateMapDisplay();
        });
        
        mapSwitchRight.addEventListener('click', (event) => {
          createRippleEffect(event);
          const currentIndex = mapIds.indexOf(this.currentMapId);
          const newIndex = (currentIndex + 1) % mapIds.length;
          this.currentMapId = mapIds[newIndex];
          updateMapDisplay();
        });
        
        // 天赋按钮事件
        healthTalentButton.onclick = () => {
          const cost = parseInt(document.getElementById('healthTalentCost').textContent);
          if (this.goldAmount >= cost) {
            this.goldAmount -= cost;
            this.healthTalentLevel++; // 增加生命天赋等级
            // 根据公式计算新的最大生命值：baseHP + 20 × 生命等级
            this.playerHealth = GameConfig.PLAYER.INITIAL_HEALTH + 20 * this.healthTalentLevel;
            this.updateTalentGoldDisplay();
            this.updateTalentLevelDisplays();
            this.generateTalentCosts();
          }
        };
        
        shieldTalentButton.onclick = () => {
          const cost = parseInt(document.getElementById('shieldTalentCost').textContent);
          if (this.goldAmount >= cost) {
            this.goldAmount -= cost;
            this.shieldTalentLevel++; // 增加护盾天赋等级
            // 根据公式计算新的初始护盾值：baseShield + 20 × 护盾等级
            // 这里可以在游戏开始时应用护盾效果
            this.updateTalentGoldDisplay();
            this.updateTalentLevelDisplays();
            this.generateTalentCosts();
          }
        };
        
        heroTalentButton.onclick = () => {
          const cost = parseInt(document.getElementById('heroTalentCost').textContent);
          if (this.goldAmount >= cost) {
            this.goldAmount -= cost;
            this.heroTalentLevel++; // 增加英雄天赋等级
            // 根据公式计算新的英雄数量：baseHeroCount + 英雄等级
            // 这里可以在游戏中增加英雄数量
            this.updateTalentGoldDisplay();
            this.updateTalentLevelDisplays();
            this.generateTalentCosts();
          }
        };
        
        // 标记事件已绑定
        this.talentEventsbound = true;
      }

      // 更新天赋系统金币显示
      updateTalentGoldDisplay() {
        const talentGoldAmount = document.getElementById('talentGoldAmount');
        talentGoldAmount.textContent = this.goldAmount;
        this.updateTalentButtonStates();
      }

      // 更新天赋等级显示
      updateTalentLevelDisplays() {
        // 更新顶部等级显示
        document.getElementById('healthLevelDisplay').textContent = this.healthTalentLevel;
        document.getElementById('shieldLevelDisplay').textContent = this.shieldTalentLevel;
        document.getElementById('heroLevelDisplay').textContent = this.heroTalentLevel;
        
        // 更新按钮上的等级显示
        document.getElementById('healthButtonLevel').textContent = this.healthTalentLevel;
        document.getElementById('shieldButtonLevel').textContent = this.shieldTalentLevel;
        document.getElementById('heroButtonLevel').textContent = this.heroTalentLevel;
      }

      // 初始化天赋效果
      initializeTalentEffects() {
        // 应用护盾天赋效果：baseShield + 20 × 护盾等级
        if (this.shieldTalentLevel > 0) {
          const initialShieldAmount = 20 * this.shieldTalentLevel;
          // 给玩家位置（中心格子）添加护盾
          const playerCell = this.grid.children[GameConfig.GRID_CELLS.EMPTY_CELL];
          if (playerCell) {
            // 设置护盾值
            playerCell.dataset.shieldHealth = initialShieldAmount.toString();
            
            // 创建护盾视觉效果
            const shieldLevel = Math.min(5, Math.ceil(initialShieldAmount / 20));
            const shieldContainer = document.createElement('div');
            shieldContainer.className = 'shield-container';
            shieldContainer.style.cssText = `
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              pointer-events: none;
              z-index: 10;
            `;
            
            const shieldBorder = document.createElement('div');
            shieldBorder.className = `shield-border level-${shieldLevel}`;
            shieldBorder.style.cssText = `
              position: absolute;
              top: -2px;
              left: -2px;
              right: -2px;
              bottom: -2px;
              border: 3px solid #00ffff;
              border-radius: 8px;
              animation: shieldPulse 2s infinite;
            `;
            
            const shieldHealth = document.createElement('div');
            shieldHealth.className = 'shield-health';
            shieldHealth.textContent = initialShieldAmount.toString();
            shieldHealth.style.cssText = `
              position: absolute;
              top: -15px;
              right: -5px;
              background: rgba(0, 255, 255, 0.8);
              color: white;
              padding: 2px 6px;
              border-radius: 10px;
              font-size: 10px;
              font-weight: bold;
              min-width: 20px;
              text-align: center;
            `;
            
            shieldContainer.appendChild(shieldBorder);
            shieldContainer.appendChild(shieldHealth);
            playerCell.appendChild(shieldContainer);
          }
        }
      }

      // 在游戏循环中添加怪物更新
      gameLoop() {
        if (this.currentState === GameState.PLAYING) {
          // 检查升级弹窗是否显示，如果显示则暂停怪物移动
          const upgradeDialog = document.getElementById('upgradeDialog');
          if (!upgradeDialog || upgradeDialog.style.display !== 'block') {
            this.updateMonsters();
          }
          requestAnimationFrame(() => this.gameLoop());
        }
      }

      updateWaveCount() {
        if (this.gem1WaveCount) {
          this.gem1WaveCount.textContent = `x${this.gem1PassCount}`;
          
          const gem1Cell = this.cellElements[2];
          gem1Cell.classList.remove('wave-1', 'wave-2', 'wave-3', 'wave-4', 'wave-5');
          
          if (this.gem1PassCount > 0) {
            gem1Cell.classList.add(`wave-${this.gem1PassCount}`);
          }

          gem1Cell.classList.remove('ripple');
          void gem1Cell.offsetWidth;
          gem1Cell.classList.add('ripple');
          
          setTimeout(() => {
            gem1Cell.classList.remove('ripple');
          }, 500);
        }
      }

      updateGem2Count(position) {
        const cell = this.cellElements[position];
        if (!cell) return;

        const count = this.gem2Counters[position];
        const waveCount = cell.querySelector('.wave-count');
        if (waveCount) {
          waveCount.textContent = `x${count}`;
        }
        
        cell.classList.remove('wave-1', 'wave-2');
        
        if (count > 0) {
          cell.classList.add(`wave-${count}`);
        }

        cell.classList.remove('ripple');
        void cell.offsetWidth;
        cell.classList.add('ripple');
        
        setTimeout(() => {
          cell.classList.remove('ripple');
        }, 500);

        // 检查是否达到2次，触发技能
        if (count === 2) {
          this.fireGem2SkillFromCell(position);
          this.gem2Counters[position] = 0;  // 重置该格子的计数
          this.updateGem2Count(position);  // 更新显示
        }
      }

      // 新增：从特定格子发射技能
      fireGem2SkillFromCell(position) {
        const cell = this.cellElements[position];
        if (!cell) return;

        const rect = cell.getBoundingClientRect();
        const startX = rect.left + rect.width / 2;
        const startY = rect.top + rect.height / 2;

        // 获取英雄等级，决定发射子弹数量
        const heroLevel = this.gem2Levels && this.gem2Levels[position] ? this.gem2Levels[position] : 1;
        const bulletCount = Math.min(heroLevel, 5); // 最多5发子弹
        
        // 获取最近的怪物们
        const monsters = this.findNearestMonsters(startX, startY, bulletCount);
        
        // 为每个目标发射一发子弹
        monsters.forEach((monster, index) => {
          setTimeout(() => {
            this.fireSkillBullet(startX, startY, monster, position);
          }, index * 100); // 每发子弹间隔100ms
        });
      }

      // 新增：发射单发技能子弹
      fireSkillBullet(startX, startY, targetMonster, position) {
        // 创建技能特效
        const skill = document.createElement('div');
        skill.className = 'skill';
        skill.style.left = `${startX}px`;
        skill.style.top = `${startY}px`;
        document.body.appendChild(skill);

        const targetX = targetMonster.x;
        const targetY = targetMonster.y;
        
        // 计算抛物线参数
        const dx = targetX - startX;
        const dy = targetY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const duration = distance / 300; // 速度因子
        const maxHeight = -100; // 抛物线最大高度
        
        let startTime = null;
        
        // 动画移动技能
        const animateSkill = (timestamp) => {
          if (!startTime) startTime = timestamp;
          const progress = (timestamp - startTime) / (duration * 1000);
          
          if (progress < 1) {
            // 计算抛物线路径
            const x = startX + dx * progress;
            const y = startY + dy * progress + maxHeight * Math.sin(Math.PI * progress);
            
            skill.style.left = `${x}px`;
            skill.style.top = `${y}px`;
            
            requestAnimationFrame(animateSkill);
          } else {
            // 到达目标
            skill.remove();
            
            // 根据英雄等级计算伤害
            const heroLevel = this.gem2Levels && this.gem2Levels[position] ? this.gem2Levels[position] : 1;
            const damage = GameConfig.SKILLS.GEM2.DAMAGE * heroLevel;
            this.damageMonster(targetMonster, damage);
          }
        };
        
        requestAnimationFrame(animateSkill);
      }

      // 新增：查找最近的多个怪物
      findNearestMonsters(x, y, count) {
        if (!this.monsters || this.monsters.length === 0) return [];
        
        // 计算所有怪物的距离并排序
        const monstersWithDistance = this.monsters.map(monster => {
          const dx = monster.x - x;
          const dy = monster.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return { monster, distance };
        }).sort((a, b) => a.distance - b.distance);
        
        // 返回最近的count个怪物
        return monstersWithDistance.slice(0, count).map(item => item.monster);
      }

      damageMonster(monster, damage) {
        monster.health -= damage;
      
        // 更新血条
        const healthPercentage = (monster.health / monster.maxHealth) * 100;
        monster.healthElement.style.width = `${healthPercentage}%`;
        
        // 显示伤害数字
        const damageText = document.createElement('div');
        damageText.className = 'damage-text';
        damageText.textContent = `-${damage}`;
        damageText.style.left = `${monster.x}px`;
        damageText.style.top = `${monster.y - 20}px`;
        document.body.appendChild(damageText);
        
        setTimeout(() => {
          damageText.remove();
        }, 1000);

        // 检查是否击杀
        if (monster.health <= 0) {
          const index = this.monsters.findIndex(m => m === monster);
          if (index !== -1) {
            this.removeMonster(index);
          }
        }
      }

      findNearestMonster(x, y) {
        let nearest = null;
        let minDistance = Infinity;
        let boss = null;

        this.monsters.forEach(monster => {
          const dx = monster.x - x;
          const dy = monster.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // 如果是BOSS，优先选择
          if (monster.isBoss) {
            boss = monster;
          }

          if (distance < minDistance) {
            minDistance = distance;
            nearest = monster;
          }
        });

        // 如果有BOSS，优先返回BOSS
        return boss || nearest;
      }

      // 随机选择按钮
      getRandomButtons(buttons, count) {
        // 创建按钮数组的副本
        const available = [...buttons];
        const result = [];
        
        // 随机选择指定数量的按钮
        while (result.length < count && available.length > 0) {
          const randomIndex = Math.floor(Math.random() * available.length);
          // 从可用按钮中移除并添加到结果中
          result.push(available.splice(randomIndex, 1)[0]);
        }
        
        return result;
      }

      showUpgradeDialog() {
        const dialog = document.getElementById('upgradeDialog');
        const closeButton = dialog.querySelector('.dialog-button.close-button');
        const refreshButton = dialog.querySelector('.dialog-button.refresh-button');
        const refreshCost = refreshButton.querySelector('.refresh-cost');
        const buttonsContainer = dialog.querySelector('.upgrade-buttons');
        
        // 初始化刷新次数
        this.refreshCount = 0;
        
        // 升级次数追踪
        this.upgradeCount = {
          gold: 0,
          health: 0,
          hero: 0,
          rocket: 0,
          shield: 0,
          speed: 0
        };

        // 更新刷新按钮费用显示
        const updateRefreshCost = () => {
          // 应用动态平衡公式 - 线性递增
          const nextCost = GameConfig.UPGRADES.REFRESH.COST + (GameConfig.BALANCE.COST_SCALING.REFRESH_LINEAR * this.refreshCount);
          refreshCost.textContent = nextCost;
          // 检查金币是否足够
          if (this.goldAmount < nextCost) {
            refreshCost.classList.add('insufficient');
          } else {
            refreshCost.classList.remove('insufficient');
          }
        };

        // 初始化时更新一次
        updateRefreshCost();

        // 获取所有可用按钮配置并进行初始随机选择
        const allButtons = Object.values(GameConfig.UPGRADES.BUTTONS);
        this.currentUpgradeButtons = this.getRandomButtons(allButtons, GameConfig.UPGRADES.REFRESH.BUTTON_COUNT);
        
        // 创建初始按钮
        const createButtons = () => {
          buttonsContainer.innerHTML = '';
          this.createUpgradeButtons(this.currentUpgradeButtons, buttonsContainer);
        };
        
        createButtons();

        // 清除现有的事件监听器
        const newRefreshButton = refreshButton.cloneNode(true);
        const newCloseButton = closeButton.cloneNode(true);
        refreshButton.parentNode.replaceChild(newRefreshButton, refreshButton);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);

        // 刷新按钮点击事件
        newRefreshButton.addEventListener('click', () => {
          // 应用动态平衡公式 - 线性递增
          const currentRefreshCost = GameConfig.UPGRADES.REFRESH.COST + (GameConfig.BALANCE.COST_SCALING.REFRESH_LINEAR * this.refreshCount);
          
          if (this.goldAmount >= currentRefreshCost) {
            this.goldAmount -= currentRefreshCost;
            this.updateGoldDisplay();
            
            // 增加刷新次数
            this.refreshCount++;
            updateRefreshCost();
            
            // 重新随机选择按钮并更新显示
            this.currentUpgradeButtons = this.getRandomButtons(allButtons, GameConfig.UPGRADES.REFRESH.BUTTON_COUNT);
            createButtons();
            
            // 更新按钮颜色以反映新的动态成本
            this.updateUpgradeButtonColors();
          }
        });

        // 监听金币变化
        const originalUpdateGoldDisplay = this.updateGoldDisplay;
        this.updateGoldDisplay = () => {
          originalUpdateGoldDisplay.call(this);
          updateRefreshCost();
        };

        // 关闭按钮点击事件
        newCloseButton.addEventListener('click', () => {
          console.log('Close button clicked');
          dialog.style.display = 'none';
          
          // 暂时禁止记录gem1计数
          this.allowGem1Count = false;
          
          // 只有在未达到最大波数时才更新波数
          if (this.waveNumber < this.maxWaves) {
            this.waveNumber++;
            this.waveText.textContent = `WAVE ${this.waveNumber}/7`;
            this.waveProgressFill.style.width = `${(this.waveNumber / this.maxWaves) * 100}%`;

            // 找到5号格子在移动路径中的索引
            const targetIndex = this.movementPath.indexOf(5);
            if (targetIndex !== -1) {
              // 更新当前索引
              this.currentIndex = targetIndex;
              
              // 直接移动到5号格子
              const targetCell = this.cellElements[5];
              if (targetCell) {
                const rect = targetCell.getBoundingClientRect();
                const gridRect = this.grid.getBoundingClientRect();
                // 计算居中位置：格子位置 + 格子大小的一半 - 角色大小的一半
          const cellCenterX = rect.left - gridRect.left + (rect.width / 2);
          const cellCenterY = rect.top - gridRect.top + (rect.height / 2);
          this.player.style.left = cellCenterX + 'px';
          this.player.style.top = cellCenterY + 'px';

                // 重置gem1计数并恢复允许记录状态
                this.gem1PassCount = 0;
                this.updateWaveCount();
                this.allowGem1Count = true;

                // 从5号格子开始继续正常移动
                this.startPlayerMovement();
              }
            }
            
            // 生成新一波怪物
            this.spawnWaveMonsters();
          } else {
            // 如果已经是最大波数，只重置gem1计数和恢复移动，不增加波数
            const targetIndex = this.movementPath.indexOf(5);
            if (targetIndex !== -1) {
              this.currentIndex = targetIndex;
              
              const targetCell = this.cellElements[5];
              if (targetCell) {
                const rect = targetCell.getBoundingClientRect();
                const gridRect = this.grid.getBoundingClientRect();
                const cellCenterX = rect.left - gridRect.left + (rect.width / 2);
                const cellCenterY = rect.top - gridRect.top + (rect.height / 2);
                this.player.style.left = cellCenterX + 'px';
                this.player.style.top = cellCenterY + 'px';

                this.gem1PassCount = 0;
                this.updateWaveCount();
                this.allowGem1Count = true;
                this.startPlayerMovement();
              }
            }
          }
          
          // 恢复原始的updateGoldDisplay方法
          this.updateGoldDisplay = originalUpdateGoldDisplay;
          
          // 记录波数到localStorage
          localStorage.setItem('lastWaveNumber', this.waveNumber);
        }, { once: true });

        dialog.style.display = 'block';
        clearInterval(this.moveInterval);
      }

      // 创建升级按钮
      createUpgradeButtons(buttons, container) {
        buttons.forEach(buttonConfig => {
          const button = document.createElement('button');
          button.className = `upgrade-button ${buttonConfig.ID}-button`;
          button.style.backgroundImage = `url('${buttonConfig.IMAGE}')`;
          
          // 如果是速度按钮且已达到最大次数，设置为禁用状态
          if (buttonConfig.ID === 'speed' && this.speedUpCount >= 3) {
            button.style.opacity = '0.5';
            button.style.cursor = 'not-allowed';
            button.disabled = true;
          }
          
          const buttonText = document.createElement('div');
          buttonText.className = 'upgrade-button-text';
          buttonText.textContent = buttonConfig.NAME;
          button.appendChild(buttonText);
          
          const costIndicator = document.createElement('div');
          costIndicator.className = 'cost-indicator';
          
          const coinIcon = document.createElement('div');
          coinIcon.className = 'coin-icon';
          
          const costAmount = document.createElement('span');
          costAmount.className = 'cost-amount';
          // 应用动态平衡公式 - 指数递增
          const upgradeCount = this.upgradeCount[buttonConfig.ID] || 0;
          const dynamicCost = Math.floor(buttonConfig.COST * Math.pow(GameConfig.BALANCE.COST_SCALING.UPGRADE_BASE, upgradeCount));
          costAmount.textContent = dynamicCost;
          
          // 检查金币是否足够，不够则显示红色
          if (this.goldAmount < dynamicCost) {
            costAmount.classList.add('insufficient');
          }
          
          costIndicator.appendChild(coinIcon);
          costIndicator.appendChild(costAmount);
          button.appendChild(costIndicator);

          button.onclick = () => {
            console.log('Button clicked:', buttonConfig.ID); // 添加调试日志
            
            // 重新计算动态成本
            const currentUpgradeCount = this.upgradeCount[buttonConfig.ID] || 0;
            const currentDynamicCost = Math.floor(buttonConfig.COST * Math.pow(GameConfig.BALANCE.COST_SCALING.UPGRADE_BASE, currentUpgradeCount));
            
            if (this.goldAmount >= currentDynamicCost) {
              this.goldAmount -= currentDynamicCost;
              
              // 增加升级次数
              this.upgradeCount[buttonConfig.ID] = currentUpgradeCount + 1;
              
              switch (buttonConfig.ID) {
                case 'gold':
                  // 检查是否已有金币格子
                  let existingGoldCell = null;
                  for (let i = 0; i < 9; i++) {
                    const cell = this.cellElements[i];
                    if (cell && cell.classList.contains('gold-cell')) {
                      existingGoldCell = cell;
                      break;
                    }
                  }
                  
                  if (existingGoldCell) {
                    // 如果已有金币格子，升级它
                    const currentLevel = parseInt(existingGoldCell.dataset.goldLevel || '1');
                    if (currentLevel < 5) {
                      const newLevel = currentLevel + 1;
                      existingGoldCell.dataset.goldLevel = newLevel;
                      const currentPassCount = parseInt(existingGoldCell.dataset.goldPassCount || '0');
                      this.upgradeGoldCell(existingGoldCell, newLevel);
                      this.updateGoldCellDisplay(existingGoldCell, currentPassCount, newLevel);
                    }
                  } else {
                    // 如果没有金币格子，随机选择一个格子变成金币格子
                    const availablePositions = [];
                    for (let i = 0; i < 9; i++) {
                      const cell = this.cellElements[i];
                      if (cell && !cell.classList.contains('gold-cell') && 
                          !cell.classList.contains('gem1') && !cell.classList.contains('gem2') &&
                          !cell.dataset.hasRocket && !cell.dataset.isSpeedCell) {
                        availablePositions.push(i);
                      }
                    }
                    
                    if (availablePositions.length > 0) {
                      const randomIndex = Math.floor(Math.random() * availablePositions.length);
                      const selectedPosition = availablePositions[randomIndex];
                      const cell = this.cellElements[selectedPosition];
                      
                      // 设置金币格子
                      cell.classList.add('gold-cell');
                      cell.style.backgroundImage = "url('gold1.png')";
                      cell.style.backgroundSize = 'contain';
                      cell.style.backgroundRepeat = 'no-repeat';
                      cell.style.backgroundPosition = 'center';
                      cell.dataset.isGoldCell = 'true';
                      cell.dataset.goldLevel = '1';
                      cell.dataset.goldPassCount = '0';
                      
                      // 显示初始等级信息
                      this.updateGoldCellDisplay(cell, 0, 1);
                    }
                  }
                  break;
                case 'health':
                  const maxHealth = GameConfig.PLAYER.INITIAL_HEALTH + 20 * this.healthTalentLevel;
        this.playerHealth = Math.min(maxHealth, this.playerHealth + buttonConfig.AMOUNT);
        const healthPercentage = (this.playerHealth / maxHealth) * 100;
        this.healthFill.style.width = `${healthPercentage}%`;
        this.healthText.textContent = `路飞血量：${this.playerHealth}/${maxHealth}`;
                  break;
                case 'hero':
                  if (buttonConfig.EFFECT && buttonConfig.EFFECT.TYPE === 'ADD_GEM2') {
                    // 优先升级已有英雄格子
                    const existingGem2Cells = buttonConfig.EFFECT.CONVERT_CELLS
                      .filter(pos => this.gem2Cells.includes(pos));
                    
                    if (existingGem2Cells.length > 0) {
                      // 升级已有英雄格子
                      const randomIndex = Math.floor(Math.random() * existingGem2Cells.length);
                      const selectedPosition = existingGem2Cells[randomIndex];
                      this.upgradeGem2Cell(selectedPosition);
                    } else {
                      // 没有已有英雄格子时，创建新的
                      const availableCells = buttonConfig.EFFECT.CONVERT_CELLS
                        .filter(pos => {
                          const cell = this.cellElements[pos];
                          return !this.gem2Cells.includes(pos) && 
                                 (!cell || (
                                   cell.dataset.hasRocket !== 'true' &&
                                   cell.dataset.isSpeedCell !== 'true' &&
                                   !cell.classList.contains('gem1') &&
                                   !cell.classList.contains('gold-cell')
                                 ));
                        });
                      if (availableCells.length > 0) {
                        const randomIndex = Math.floor(Math.random() * availableCells.length);
                        const selectedPosition = availableCells[randomIndex];
                        this.convertToGem2(selectedPosition);
                      }
                    }
                  }
                  break;
                case 'shield':
                  this.createShieldEffect();
                  break;
                case 'rocket':
                  if (buttonConfig.EFFECT && buttonConfig.EFFECT.TYPE === 'ADD_ROCKET') {
                    console.log('Processing rocket effect...'); // 添加调试日志
                    
                    // 首先检查是否已有火箭格子
                    let rocketCell = null;
                    for (let pos of buttonConfig.EFFECT.CONVERT_CELLS) {
                      const cell = this.cellElements[pos];
                      if (cell && cell.dataset.hasRocket === 'true') {
                        rocketCell = cell;
                        break;
                      }
                    }
                    
                    if (rocketCell) {
                      // 如果已有火箭格子，升级火箭等级
                      const currentLevel = parseInt(rocketCell.dataset.rocketLevel || '1');
                      const newLevel = Math.min(5, currentLevel + 1); // 最大等级5
                      rocketCell.dataset.rocketLevel = newLevel;
                      
                      // 更新等级显示
                      let oldLevelText = rocketCell.querySelector('.rocket-level-info');
                      if (oldLevelText) {
                        oldLevelText.remove();
                      }
                      
                      // 创建新的等级显示，位置在右下角
                      const rocketInfoDiv = document.createElement('div');
                      rocketInfoDiv.className = 'rocket-level-info';
                      rocketInfoDiv.innerHTML = `<div class="gold-level">Lv.${newLevel}</div>`;
                      rocketInfoDiv.style.cssText = `
                        position: absolute;
                        bottom: 2px;
                        right: 2px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        font-size: 10px;
                        padding: 2px 4px;
                        border-radius: 3px;
                        line-height: 1;
                      `;
                      
                      rocketCell.appendChild(rocketInfoDiv);
                    } else {
                      // 如果没有火箭格子，创建新的
                      const availableCells = buttonConfig.EFFECT.CONVERT_CELLS.filter(pos => {
                        const cell = this.cellElements[pos];
                        return cell && !cell.classList.contains('gem1') && !cell.classList.contains('gem2') &&
                               cell.dataset.isSpeedCell !== 'true' && !cell.classList.contains('gold-cell');
                      });
                      
                      if (availableCells.length > 0) {
                        const randomIndex = Math.floor(Math.random() * availableCells.length);
                        const selectedPosition = availableCells[randomIndex];
                        const cell = this.cellElements[selectedPosition];
                        
                        // 设置初始状态
                        cell.dataset.hasRocket = 'true';
                        cell.dataset.passCount = '0';
                        cell.dataset.rocketLevel = '1'; // 初始等级为1
                        cell.innerHTML = ''; // 清除现有内容
                        
                        // 创建火箭图片
                        const rocketImg = document.createElement('img');
                        rocketImg.src = 'rocket.png';
                        rocketImg.className = 'cell-image';
                        cell.appendChild(rocketImg);

                        // 创建水位效果容器
                        const waterEffect = document.createElement('div');
                        waterEffect.className = 'water-effect';
                        cell.appendChild(waterEffect);
                        
                        // 创建等级显示，位置在右下角
                        const rocketInfoDiv = document.createElement('div');
                        rocketInfoDiv.className = 'rocket-level-info';
                        rocketInfoDiv.innerHTML = `<div class="gold-level">Lv.1</div>`;
                        rocketInfoDiv.style.cssText = `
                          position: absolute;
                          bottom: 2px;
                          right: 2px;
                          background: rgba(0, 0, 0, 0.7);
                          color: white;
                          font-size: 10px;
                          padding: 2px 4px;
                          border-radius: 3px;
                          line-height: 1;
                        `;
                        cell.appendChild(rocketInfoDiv);
                        
                        // 创建经过次数显示
                        const passCountText = document.createElement('div');
                        passCountText.className = 'wave-count';
                        passCountText.textContent = 'x0';
                        passCountText.style.right = '2px';
                        passCountText.style.top = '2px';
                        cell.appendChild(passCountText);
                      }
                    }
                  }
                  break;
                case 'speed':
                  this.increasePlayerSpeed();
                  break;
              }
              
              this.updateGoldDisplay();
              
              // 重新创建按钮以显示新的动态成本
              createButtons();
            }
          };

          container.appendChild(button);
        });
      }

      // 修改盾牌效果创建方法
      createShieldEffect() {
        const grid = document.getElementById('grid');
        if (!grid) return;

        // 获取当前盾牌血量，如果没有则为0
        const currentShieldHealth = parseInt(grid.dataset.shieldHealth || '0');
        // 新的盾牌血量 = 当前血量 + 20
        const newShieldHealth = currentShieldHealth + 20;

        // 计算盾牌等级（每20点血量一个等级）
        const shieldLevel = Math.min(5, Math.ceil(newShieldHealth / 20));

        // 如果已经有盾牌效果，更新血量和光效
        let shieldContainer = grid.querySelector('.shield-container');
        if (shieldContainer) {
          const shieldHealth = shieldContainer.querySelector('.shield-health');
          const shieldBorder = shieldContainer.querySelector('.shield-border');
          
          if (shieldHealth) {
            shieldHealth.textContent = newShieldHealth.toString();
          }
          
          if (shieldBorder) {
            // 移除所有等级类名
            shieldBorder.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5');
            // 添加新的等级类名
            shieldBorder.classList.add(`level-${shieldLevel}`);
          }
          
          grid.dataset.shieldHealth = newShieldHealth.toString();
          return;
        }

        // 如果没有盾牌效果，创建新的盾牌
        shieldContainer = document.createElement('div');
        shieldContainer.className = 'shield-container';
        shieldContainer.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 10;
        `;
        
        // 添加盾牌图标和发光效果到边界
        const shieldBorder = document.createElement('div');
        shieldBorder.className = `shield-border level-${shieldLevel}`;
        shieldBorder.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          animation: shieldPulse 2s infinite;
          pointer-events: none;
        `;

        // 添加盾牌血量显示
        const shieldHealth = document.createElement('div');
        shieldHealth.className = 'shield-health';
        shieldHealth.textContent = newShieldHealth.toString();
        shieldHealth.style.cssText = `
          position: absolute;
          top: 0px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 255, 255, 0.3);
          color: white;
          padding: 2px 8px;
          border-radius: 10px;
          font-size: 12px;
          z-index: 11;
        `;

        shieldContainer.appendChild(shieldBorder);
        shieldContainer.appendChild(shieldHealth);
        grid.appendChild(shieldContainer);
        
        // 记录盾牌血量到grid元素
        grid.dataset.shieldHealth = newShieldHealth.toString();
      }

      // 新增方法：创建火箭效果
      createRocketEffect() {
        const availableCells = this.movementPath.filter(pos => 
          !this.cellElements[pos].querySelector('.rocket'));
        
        if (availableCells.length > 0) {
          const randomIndex = Math.floor(Math.random() * availableCells.length);
          const selectedPosition = availableCells[randomIndex];
          const cell = this.cellElements[selectedPosition];
          
          cell.dataset.hasRocket = 'true';
          
          // 当角色经过此格子时会触发火箭发射
          // 在startPlayerMovement方法中添加检查
        }
      }

      // 修改 increasePlayerSpeed 方法
      increasePlayerSpeed() {
        // 检查是否已达到最大加速次数
        if (this.speedUpCount >= 3) {
          return;
        }

        this.speedUpCount++;  // 增加速度提升计数

        // 检查是否已经有speed格子
        let speedCell = null;
        for (let pos of this.movementPath) {
          const cell = this.cellElements[pos];
          if (cell && cell.classList.contains('speed')) {
            speedCell = cell;
            break;
          }
        }

        // 如果没有speed格子，随机选择一个位置创建
        if (!speedCell) {
          const availableCells = this.movementPath.filter(pos => {
            const cell = this.cellElements[pos];
            return !cell.classList.contains('gem1') && 
                   !cell.classList.contains('gem2') &&
                   cell.dataset.hasRocket !== 'true' &&
                   !cell.classList.contains('gold-cell') &&
                   !cell.classList.contains('speed') &&
                   !cell.dataset.isSpeedCell;
          });
          
          if (availableCells.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableCells.length);
            const selectedPosition = availableCells[randomIndex];
            speedCell = this.cellElements[selectedPosition];
            speedCell.classList.add('speed');
            speedCell.dataset.isSpeedCell = 'true';
          }
        }

        if (speedCell) {
          // 更新速度等级
          speedCell.dataset.speedLevel = this.speedUpCount.toString();

          // 添加或更新速度等级显示
          let oldSpeedText = speedCell.querySelector('.gold-level');
          if (oldSpeedText) {
            oldSpeedText.remove();
          }
          
          // 创建新的等级显示，位置在右下角
          const speedInfoDiv = document.createElement('div');
          speedInfoDiv.className = 'speed-level-info';
          speedInfoDiv.innerHTML = `<div class="gold-level">Lv.${this.speedUpCount}</div>`;
          speedInfoDiv.style.cssText = `
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            line-height: 1;
          `;
          
          speedCell.appendChild(speedInfoDiv);

          // 如果玩家当前在speed格子上，立即应用速度效果
          const currentCell = this.cellElements[this.movementPath[this.currentIndex]];
          if (currentCell === speedCell) {
            if (this.moveInterval) {
              clearInterval(this.moveInterval);
              this.moveInterval = setInterval(() => {
                const movePlayer = this.startPlayerMovement.bind(this);
                movePlayer();
              }, Math.max(200, 500 - (this.speedUpCount * 100)));
            }
          }

          // 如果达到最大加速次数，禁用速度按钮
          if (this.speedUpCount >= 3) {
            const speedButton = document.querySelector('.speed-button');
            if (speedButton) {
              speedButton.style.opacity = '0.5';
              speedButton.style.cursor = 'not-allowed';
              speedButton.disabled = true;
            }
          }
        }
      }

      // 修改发射火箭方法 - 可以击打多个怪物
      fireRocket(sourceCell, targetMonster = null) {
        const rocket = document.createElement('div');
        rocket.className = 'rocket';
        document.body.appendChild(rocket);
        
        const cellRect = sourceCell.getBoundingClientRect();
        const startX = cellRect.left + cellRect.width / 2;
        const startY = cellRect.top + cellRect.height / 2;
        
        rocket.style.left = `${startX}px`;
        rocket.style.top = `${startY}px`;
        
        // 如果没有指定目标，寻找最近的怪物
        const monster = targetMonster || this.findNearestMonster(startX, startY);
        if (monster) {
          const targetX = monster.x;
          const targetY = monster.y;
          
          const dx = targetX - startX;
          const dy = targetY - startY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const rocketConfig = GameConfig.GRID_CELLS.SPECIAL_CELLS.ROCKET;
          const duration = rocketConfig.ANIMATION_DURATION;
          const damage = monster.isBoss ? rocketConfig.DAMAGE.BOSS : rocketConfig.DAMAGE.NORMAL;
          const maxHeight = -100;
          
          let startTime = null;
          
          const animateRocket = (timestamp) => {
            if (!startTime) startTime = timestamp;
            const progress = (timestamp - startTime) / duration;
            
            if (progress < 1) {
              const x = startX + dx * progress;
              const y = startY + dy * progress + maxHeight * Math.sin(Math.PI * progress);
              
              rocket.style.left = `${x}px`;
              rocket.style.top = `${y}px`;
              
              // 计算旋转角度
              const angle = Math.atan2(dy, dx) * 180 / Math.PI;
              rocket.style.transform = `rotate(${angle}deg)`;
              
              requestAnimationFrame(animateRocket);
            } else {
              rocket.remove();
              this.damageMonster(monster, damage);
            }
          };
          
          requestAnimationFrame(animateRocket);
        } else {
          // 如果没有目标，移除火箭
          rocket.remove();
        }
      }

      // 显示获得金币的文字效果
      showGoldGainEffect(cell, goldAmount) {
        const gainText = document.createElement('div');
        gainText.textContent = `+${goldAmount}`;
        gainText.style.cssText = `
          position: absolute;
          color: #FFD700;
          font-weight: bold;
          font-size: 16px;
          pointer-events: none;
          z-index: 1000;
          animation: goldGainFloat 1.5s ease-out forwards;
          text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
        `;
        
        const cellRect = cell.getBoundingClientRect();
        gainText.style.left = `${cellRect.left + cellRect.width / 2}px`;
        gainText.style.top = `${cellRect.top}px`;
        
        document.body.appendChild(gainText);
        
        setTimeout(() => {
          if (gainText.parentNode) {
            gainText.parentNode.removeChild(gainText);
          }
        }, 1500);
      }
      
      // 升级金币格子
      upgradeGoldCell(cell, newLevel) {
        // 不再改变格子颜色，保持原样
        // 显示升级效果
        const upgradeText = document.createElement('div');
        upgradeText.textContent = `升级到 Lv.${newLevel}!`;
        upgradeText.style.cssText = `
          position: absolute;
          color: #FF6B6B;
          font-weight: bold;
          font-size: 14px;
          pointer-events: none;
          z-index: 1000;
          animation: upgradeFloat 2s ease-out forwards;
        `;
        
        const cellRect = cell.getBoundingClientRect();
        upgradeText.style.left = `${cellRect.left + cellRect.width / 2 - 40}px`;
        upgradeText.style.top = `${cellRect.top - 20}px`;
        
        document.body.appendChild(upgradeText);
        
        setTimeout(() => {
          if (upgradeText.parentNode) {
            upgradeText.parentNode.removeChild(upgradeText);
          }
        }, 2000);
      }
      
      // 更新金币格子显示
      updateGoldCellDisplay(cell, passCount, level) {
        // 移除旧的显示元素
        const oldDisplay = cell.querySelector('.gold-cell-info');
        if (oldDisplay) {
          oldDisplay.remove();
        }
        
        // 创建新的显示元素，只显示等级，不显示进度
        const infoDiv = document.createElement('div');
        infoDiv.className = 'gold-cell-info';
        infoDiv.innerHTML = `
          <div class="gold-level">Lv.${level}</div>
        `;
        infoDiv.style.cssText = `
          position: absolute;
          bottom: 2px;
          right: 2px;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          font-size: 10px;
          padding: 2px 4px;
          border-radius: 3px;
          line-height: 1;
        `;
        
        cell.appendChild(infoDiv);
      }

      clearCurrentWave() {
        console.log('Clearing current wave, monsters:', this.monsters.length);
        this.monsters.forEach(monster => {
          if (monster.element && monster.element.parentNode) {
            monster.element.parentNode.removeChild(monster.element);
          }
        });
        this.monsters = [];
      }

      // 背景音乐相关方法
      initBackgroundMusic() {
        try {
          this.backgroundMusic = new Audio('Music_fx_ (3).mp3');
          this.backgroundMusic.loop = true;
          this.backgroundMusic.volume = 0.5;
          
          // 添加音乐控制按钮
          this.createMusicToggleButton();
          
          console.log('Background music initialized');
        } catch (error) {
          console.error('Error initializing background music:', error);
        }
      }

      playBackgroundMusic() {
        if (this.backgroundMusic && this.musicEnabled) {
          try {
            this.backgroundMusic.play().catch(error => {
              console.log('Auto-play prevented by browser policy:', error);
              // 浏览器阻止自动播放，用户需要手动点击
            });
          } catch (error) {
            console.error('Error playing background music:', error);
          }
        }
      }

      pauseBackgroundMusic() {
        if (this.backgroundMusic) {
          this.backgroundMusic.pause();
        }
      }

      toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        if (this.musicEnabled) {
          this.playBackgroundMusic();
        } else {
          this.pauseBackgroundMusic();
        }
        this.updateMusicButton();
      }

      createMusicToggleButton() {
        const musicButton = document.createElement('button');
        musicButton.id = 'music-toggle-btn';
        musicButton.innerHTML = '🎵';
        musicButton.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          width: 50px;
          height: 50px;
          border: none;
          border-radius: 50%;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          font-size: 20px;
          cursor: pointer;
          z-index: 1000;
          transition: all 0.3s ease;
        `;
        
        musicButton.addEventListener('click', () => {
          this.toggleMusic();
        });
        
        musicButton.addEventListener('mouseenter', () => {
          musicButton.style.background = 'rgba(0, 0, 0, 0.9)';
          musicButton.style.transform = 'scale(1.1)';
        });
        
        musicButton.addEventListener('mouseleave', () => {
          musicButton.style.background = 'rgba(0, 0, 0, 0.7)';
          musicButton.style.transform = 'scale(1)';
        });
        
        document.body.appendChild(musicButton);
        this.musicButton = musicButton;
      }

      updateMusicButton() {
        if (this.musicButton) {
          this.musicButton.innerHTML = this.musicEnabled ? '🎵' : '🔇';
          this.musicButton.title = this.musicEnabled ? '点击关闭音乐' : '点击开启音乐';
        }
      }
    }

    // 当页面加载完成时初始化游戏
    window.addEventListener('load', () => {
      window.game = new Game();
    });
  </script>


<div id="eagle-drag-images" style="position: fixed; top: -100000px;"></div>
<script>
// ========== 全局地图变量 ==========
let currentMapIndex = 1;
const maxMapIndex = 3;

// ========== 切换地图 ==========
function switchMap(direction) {
  if (direction === 'left') {
    currentMapIndex = currentMapIndex > 1 ? currentMapIndex - 1 : maxMapIndex;
  } else if (direction === 'right') {
    currentMapIndex = currentMapIndex < maxMapIndex ? currentMapIndex + 1 : 1;
  }
  localStorage.setItem('currentMapIndex', currentMapIndex);
  updateMapDisplay();
}

// ========== 更新地图显示到所有界面 ==========
function updateMapDisplay() {
  const bgUrl = `url('map${currentMapIndex}.jpg')`;

  const gameContainer = document.getElementById('game-container');
  if (gameContainer) gameContainer.style.backgroundImage = bgUrl;

  const battleScreen = document.getElementById('battle-screen');
  if (battleScreen) {
    battleScreen.style.backgroundImage = bgUrl;
    battleScreen.style.backgroundSize = 'cover';
    battleScreen.style.backgroundPosition = 'center';
  }

  const talentMap = document.querySelector('.talent-map-image');
  if (talentMap) {
    talentMap.src = `map${currentMapIndex}.jpg`;
  }
}

// ========== 初始化地图状态 ==========
window.addEventListener('load', () => {
  const saved = localStorage.getItem('currentMapIndex');
  if (saved) currentMapIndex = parseInt(saved);
  updateMapDisplay();
});

// ========== 进入战斗和天赋界面 ==========
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('battle-screen').style.display = 'block';
  updateMapDisplay();
}

function openTalentSystem() {
  document.querySelector('.talent-system').style.display = 'block';
  updateMapDisplay();
}
</script>

</body></html>